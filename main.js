/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/constants/styles.ts
var MODAL_STYLES, INPUT_STYLES;
var init_styles = __esm({
  "src/constants/styles.ts"() {
    MODAL_STYLES = {
      zIndex: "10000",
      display: "flex",
      header: {
        marginBottom: "15px",
        color: "var(--text-accent)"
      },
      message: {
        marginBottom: "20px",
        lineHeight: "1.5"
      },
      buttonContainer: {
        marginTop: "20px",
        display: "flex",
        gap: "10px",
        justifyContent: "flex-end"
      },
      button: {
        padding: "8px 16px",
        minWidth: "100px"
      }
    };
    INPUT_STYLES = {
      width: "100%",
      marginTop: "8px",
      padding: "8px",
      border: "1px solid var(--background-modifier-border)",
      borderRadius: "4px"
    };
  }
});

// src/utils/dom.ts
var DOMUtils;
var init_dom = __esm({
  "src/utils/dom.ts"() {
    init_styles();
    DOMUtils = class {
      /**
       * Apply styles to an HTML element
       */
      static applyStyles(element, styles) {
        Object.assign(element.style, styles);
      }
      /**
       * Create a standardized button container
       */
      static createButtonContainer(parent) {
        const container = parent.createDiv();
        this.applyStyles(container, MODAL_STYLES.buttonContainer);
        return container;
      }
      /**
       * Create a styled button with consistent appearance
       */
      static createStyledButton(container, text, isPrimary = false, onClick) {
        const button = container.createEl("button", { text });
        if (isPrimary) {
          button.classList.add("mod-cta");
        }
        this.applyStyles(button, MODAL_STYLES.button);
        if (onClick) {
          button.addEventListener("click", onClick);
        }
        return button;
      }
      /**
       * Create a styled input field
       */
      static createStyledInput(container, type, placeholder, value = "") {
        const input = container.createEl("input", {
          type,
          placeholder,
          value
        });
        this.applyStyles(input, INPUT_STYLES);
        return input;
      }
      /**
       * Set up modal base styling for consistency
       */
      static setupModalStyling(modalEl) {
        this.applyStyles(modalEl, {
          zIndex: MODAL_STYLES.zIndex,
          display: MODAL_STYLES.display
        });
      }
      /**
       * Create a header element with consistent styling
       */
      static createModalHeader(parent, text) {
        const header = parent.createEl("h2", { text });
        this.applyStyles(header, MODAL_STYLES.header);
        return header;
      }
      /**
       * Create a message paragraph with consistent styling
       */
      static createModalMessage(parent, text) {
        const message = parent.createEl("p");
        message.setText(text);
        this.applyStyles(message, MODAL_STYLES.message);
        return message;
      }
      /**
       * Set up keyboard event handlers for modals
       */
      static setupModalKeyHandlers(element, onEnter, onEscape) {
        element.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            e.stopPropagation();
            onEnter();
          }
          if (e.key === "Escape" && onEscape) {
            e.preventDefault();
            e.stopPropagation();
            onEscape();
          }
        });
      }
      // Instance methods implementing interface
      applyStyles(element, styles) {
        DOMUtils.applyStyles(element, styles);
      }
      createButtonContainer(parent) {
        return DOMUtils.createButtonContainer(parent);
      }
      createStyledButton(container, text, isPrimary = false, onClick) {
        return DOMUtils.createStyledButton(container, text, isPrimary, onClick);
      }
    };
  }
});

// src/constants/api.ts
var API_ENDPOINTS, AI_MODELS, PROVIDER_MODEL_OPTIONS, PROVIDER_MODEL_LIST_URLS, PROVIDER_MODEL_REGEX, API_LIMITS, TIMEOUTS;
var init_api = __esm({
  "src/constants/api.ts"() {
    API_ENDPOINTS = {
      GEMINI: "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent",
      GROQ: "https://api.groq.com/openai/v1/chat/completions",
      YOUTUBE_OEMBED: "https://www.youtube.com/oembed",
      CORS_PROXY: "https://api.allorigins.win/raw"
    };
    AI_MODELS = {
      GEMINI: "gemini-2.5-pro",
      // Set Gemini model to gemini-2.5-pro
      GROQ: "llama-3.3-70b-versatile"
    };
    PROVIDER_MODEL_OPTIONS = {
      "Google Gemini": [
        // Gemini 2.5 series (latest, all support multimodal video analysis)
        { name: "gemini-2.5-pro", supportsAudioVideo: true },
        { name: "gemini-2.5-pro-tts", supportsAudioVideo: true },
        { name: "gemini-2.5-flash", supportsAudioVideo: true },
        { name: "gemini-2.5-flash-lite", supportsAudioVideo: true },
        // Gemini 2.0 series (video support via native API, but no explicit multimodal flag)
        { name: "gemini-2.0-pro", supportsAudioVideo: true },
        { name: "gemini-2.0-flash" },
        { name: "gemini-2.0-flash-lite" },
        // Gemini 1.5 series (available, supports video via File API)
        { name: "gemini-1.5-pro" },
        { name: "gemini-1.5-flash" }
      ],
      "Groq": [
        // Latest models (Nov 2024 - Nov 2025)
        // Note: Groq models prioritize speed/text; for multimodal video, Gemini is recommended
        { name: "llama-4-maverick-17b-128e-instruct" },
        { name: "llama-4-scout-17b-16e-instruct" },
        // Llama 3.x series
        { name: "llama-3.3-70b-versatile" },
        { name: "llama-3.1-8b-instant" }
      ]
    };
    PROVIDER_MODEL_LIST_URLS = {
      "Google Gemini": "https://developers.generativeai.google/models",
      "Groq": "https://groq.com"
    };
    PROVIDER_MODEL_REGEX = {
      "Google Gemini": /gemini[-_\.]?\d+(?:\.\d+)?(?:-[a-z0-9\-]+)?/gi,
      "Groq": /llama[-_\.]?\d+(?:\.\d+)?(?:-[a-z0-9\-]+)?/gi
    };
    API_LIMITS = {
      MAX_TOKENS: 2e3,
      TEMPERATURE: 0.7,
      DESCRIPTION_MAX_LENGTH: 1e3,
      TITLE_MAX_LENGTH: 100
    };
    TIMEOUTS = {
      FILE_CREATION_WAIT: 300,
      MODAL_DELAY: 100,
      FALLBACK_MODAL_CHECK: 500,
      FOCUS_DELAY: 150,
      REPAINT_DELAY: 50
    };
  }
});

// src/components/modals/confirmation-modal.ts
var confirmation_modal_exports = {};
__export(confirmation_modal_exports, {
  ConfirmationModal: () => ConfirmationModal
});
var ConfirmationModal;
var init_confirmation_modal = __esm({
  "src/components/modals/confirmation-modal.ts"() {
    init_base_modal();
    ConfirmationModal = class extends BaseModal {
      constructor(app, options) {
        super(app);
        this.options = options;
        this.result = false;
      }
      onOpen() {
        this.createModalContent();
        this.setupEventHandlers();
        this.focusConfirmButton();
      }
      /**
       * Create modal content with accessible structure
       */
      createModalContent() {
        const header = this.createHeader(this.options.title);
        header.setAttribute("id", "confirmation-modal-title");
        const messageContainer = this.contentEl.createDiv("confirmation-message");
        messageContainer.setAttribute("id", "confirmation-modal-description");
        messageContainer.textContent = this.options.message;
        const buttonContainer = this.createButtonContainer();
        buttonContainer.style.marginTop = "20px";
        const confirmText = this.options.confirmText || "Confirm";
        const cancelText = this.options.cancelText || "Cancel";
        const isDangerous = this.options.isDangerous || false;
        if (isDangerous) {
          this.cancelButton = this.createButton(
            buttonContainer,
            cancelText,
            false,
            () => this.handleCancel()
          );
          this.cancelButton.setAttribute("aria-label", `Cancel: ${cancelText}`);
          this.confirmButton = this.createButton(
            buttonContainer,
            confirmText,
            true,
            () => this.handleConfirm()
          );
          this.confirmButton.setAttribute("aria-label", `Confirm: ${confirmText}`);
        } else {
          this.confirmButton = this.createButton(
            buttonContainer,
            confirmText,
            true,
            () => this.handleConfirm()
          );
          this.confirmButton.setAttribute("aria-label", `Confirm: ${confirmText}`);
          this.cancelButton = this.createButton(
            buttonContainer,
            cancelText,
            false,
            () => this.handleCancel()
          );
          this.cancelButton.setAttribute("aria-label", `Cancel: ${cancelText}`);
        }
        this.contentEl.setAttribute("aria-labelledby", "confirmation-modal-title");
        this.contentEl.setAttribute("aria-describedby", "confirmation-modal-description");
        this.contentEl.setAttribute("role", "alertdialog");
      }
      /**
       * Set up keyboard event handlers (Enter to confirm, Escape to cancel)
       */
      setupEventHandlers() {
        this.scope.register([], "Enter", () => {
          this.handleConfirm();
          return false;
        });
        this.scope.register([], "Escape", () => {
          this.handleCancel();
          return false;
        });
      }
      /**
       * Focus the confirm button by default
       */
      focusConfirmButton() {
        if (this.confirmButton) {
          setTimeout(() => {
            this.confirmButton.focus();
          }, 50);
        }
      }
      /**
       * Handle confirmation (Confirm button or Enter key)
       */
      handleConfirm() {
        this.result = true;
        if (this.resolver) {
          this.resolver(true);
        }
        this.close();
      }
      /**
       * Handle cancellation (Cancel button or Escape key)
       */
      handleCancel() {
        this.result = false;
        if (this.resolver) {
          this.resolver(false);
        }
        this.close();
      }
      /**
       * Open modal and wait for user response
       * Returns promise that resolves to true if confirmed, false if cancelled
       */
      openAndWait() {
        return new Promise((resolve) => {
          this.resolver = resolve;
          this.open();
        });
      }
      /**
       * Get the result (synchronous if already closed)
       */
      getResult() {
        return this.result;
      }
    };
  }
});

// src/components/modals/base-modal.ts
var import_obsidian3, MODAL_CSS_CLASSES, BaseModal;
var init_base_modal = __esm({
  "src/components/modals/base-modal.ts"() {
    import_obsidian3 = require("obsidian");
    init_dom();
    init_styles();
    init_api();
    MODAL_CSS_CLASSES = {
      modal: "ytc-modal",
      header: "ytc-modal-header",
      content: "ytc-modal-content",
      button: "ytc-modal-button",
      input: "ytc-modal-input"
    };
    BaseModal = class extends import_obsidian3.Modal {
      constructor(app) {
        super(app);
        this.events = {};
        this.isDisposed = false;
        this.setupModalStyling();
        this.setupConflictPrevention();
      }
      /**
       * Set up base modal styling for consistency
       */
      setupModalStyling() {
        DOMUtils.setupModalStyling(this.modalEl);
        this.modalEl.addClass(MODAL_CSS_CLASSES.modal);
        this.contentEl.addClass(MODAL_CSS_CLASSES.content);
      }
      /**
       * Set up conflict prevention measures
       */
      setupConflictPrevention() {
        this.modalEl.setAttribute("data-plugin", "youtube-clipper");
        this.modalEl.style.zIndex = "9999";
      }
      /**
       * Create standardized modal header with conflict prevention
       */
      createHeader(text) {
        const header = DOMUtils.createModalHeader(this.contentEl, text);
        header.addClass(MODAL_CSS_CLASSES.header);
        return header;
      }
      /**
       * Create standardized modal message
       */
      createMessage(text) {
        return DOMUtils.createModalMessage(this.contentEl, text);
      }
      /**
       * Create standardized button container
       */
      createButtonContainer() {
        return DOMUtils.createButtonContainer(this.contentEl);
      }
      /**
      * Create standardized button with conflict prevention and accessibility
      */
      createButton(container, text, isPrimary = false, onClick) {
        const button = DOMUtils.createStyledButton(container, text, isPrimary, onClick);
        button.addClass(MODAL_CSS_CLASSES.button);
        button.setAttribute("data-plugin", "youtube-clipper");
        button.setAttribute("role", "button");
        if (!button.getAttribute("aria-label")) {
          button.setAttribute("aria-label", text);
        }
        return button;
      }
      /**
       * Create standardized input with conflict prevention and accessibility
       */
      createInput(container, type, placeholder) {
        const input = container.createEl("input", {
          type,
          placeholder
        });
        DOMUtils.applyStyles(input, INPUT_STYLES);
        input.addClass(MODAL_CSS_CLASSES.input);
        input.setAttribute("data-plugin", "youtube-clipper");
        if (placeholder) {
          input.setAttribute("aria-label", placeholder);
        }
        return input;
      }
      /**
       * Set up keyboard event handlers
       */
      setupKeyHandlers(onEnter, onEscape) {
        const wrappedOnEnter = async () => {
          try {
            await onEnter();
          } catch (error) {
            console.error("Enter key handler error:", error);
          }
        };
        const wrappedOnEscape = onEscape ? async () => {
          try {
            await onEscape();
          } catch (error) {
            console.error("Escape key handler error:", error);
          }
        } : void 0;
        DOMUtils.setupModalKeyHandlers(this.contentEl, wrappedOnEnter, wrappedOnEscape);
      }
      /**
       * Focus element with delay for better UX
       */
      focusElement(element, delay = TIMEOUTS.FOCUS_DELAY) {
        setTimeout(() => {
          element.focus();
        }, delay);
      }
      /**
       * Set up event handlers
       */
      setEvents(events) {
        this.events = events;
      }
      /**
       * Show custom styled confirmation dialog before closing
       * This uses our custom ConfirmationModal instead of the native browser confirm()
       * for better accessibility and UX.
       * 
       * Note: This is now synchronous for backwards compatibility with existing callers,
       * but returns a boolean immediately. For async confirmation with proper modal,
       * use showConfirmationModal() instead.
       */
      confirmClose(message) {
        return confirm(message);
      }
      /**
       * Show a custom accessible confirmation modal and wait for user response.
       * Preferred method for confirmation dialogs (async, fully accessible).
       */
      async showConfirmationModal(title, message, confirmText = "Confirm", cancelText = "Cancel", isDangerous = false) {
        const { ConfirmationModal: ConfirmationModal2 } = await Promise.resolve().then(() => (init_confirmation_modal(), confirmation_modal_exports));
        const modal = new ConfirmationModal2(this.app, {
          title,
          message,
          confirmText,
          cancelText,
          isDangerous
        });
        return modal.openAndWait();
      }
      /**
       * Force modal visibility (for stubborn modals)
       */
      forceVisible() {
        setTimeout(() => {
          DOMUtils.setupModalStyling(this.modalEl);
        }, TIMEOUTS.REPAINT_DELAY);
      }
      /**
       * Clean up on close with proper disposal
       */
      onClose() {
        if (this.isDisposed) {
          return;
        }
        console.log("[youtube-clipper] Cleaning up modal");
        this.isDisposed = true;
        const { contentEl } = this;
        contentEl.empty();
        this.modalEl.removeClass(MODAL_CSS_CLASSES.modal);
        this.modalEl.removeAttribute("data-plugin");
        console.log("[youtube-clipper] Modal cleanup complete");
      }
    };
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => YouTubeProcessorPlugin
});
module.exports = __toCommonJS(main_exports);

// src/main.ts
var import_obsidian7 = require("obsidian");

// src/utils/conflict-prevention.ts
var ConflictPrevention = class {
  /**
   * Check if another plugin might be conflicting
   */
  static checkForPotentialConflicts() {
    const warnings = [];
    const suspiciousElements = [
      'div[data-plugin="web-clipper"]',
      ".web-clipper-modal",
      ".clipper-button",
      '[id*="clipper"]',
      '[class*="clip"]'
    ];
    suspiciousElements.forEach((selector) => {
      const elements = document.querySelectorAll(selector);
      if (elements.length > 0) {
        warnings.push(`Detected potential plugin conflict: ${selector}`);
      }
    });
    return warnings;
  }
  /**
   * Add conflict prevention attributes to an element
   */
  static markElement(element, type) {
    element.setAttribute("data-plugin", this.PLUGIN_ID);
    element.setAttribute("data-ytc-type", type);
    element.addClass(`${this.CSS_PREFIX}-${type}`);
  }
  /**
   * Remove conflict prevention attributes
   */
  static unmarkElement(element) {
    element.removeAttribute("data-plugin");
    element.removeAttribute("data-ytc-type");
    const classes = Array.from(element.classList);
    classes.forEach((className) => {
      if (className.startsWith(this.CSS_PREFIX)) {
        element.removeClass(className);
      }
    });
  }
  /**
   * Create a namespaced ID to prevent conflicts
   */
  static createUniqueId(base) {
    return `${this.CSS_PREFIX}-${base}-${Date.now()}`;
  }
  /**
   * Clean up all plugin elements from DOM
   */
  static cleanupAllElements() {
    const elements = document.querySelectorAll(`[data-plugin="${this.PLUGIN_ID}"]`);
    elements.forEach((element) => {
      if (element instanceof HTMLElement) {
        this.unmarkElement(element);
      }
    });
  }
  /**
   * Get safe storage key with namespace
   */
  static getStorageKey(key) {
    return `${this.PLUGIN_ID}-${key}`;
  }
  /**
   * Log plugin activity with namespace
   */
  static log(message, level = "info") {
    const timestamp = new Date().toISOString();
    const logMessage = `[${this.PLUGIN_ID}] ${timestamp} - ${message}`;
    switch (level) {
      case "warn":
        console.warn(logMessage);
        break;
      case "error":
        console.error(logMessage);
        break;
      default:
        console.log(logMessage);
    }
  }
  /**
   * Check if plugin is safe to operate
   */
  static isSafeToOperate() {
    const conflicts = this.checkForPotentialConflicts();
    if (conflicts.length > 0) {
      this.log(`Potential conflicts detected: ${conflicts.join(", ")}`, "warn");
      return false;
    }
    return true;
  }
  /**
   * Wrap async operations with conflict checking
   */
  static async safeOperation(operation, operationName) {
    if (!this.isSafeToOperate()) {
      this.log(`Skipping ${operationName} due to potential conflicts`, "warn");
      return null;
    }
    try {
      this.log(`Starting ${operationName}`);
      const result = await operation();
      this.log(`Completed ${operationName}`);
      return result;
    } catch (error) {
      this.log(`Error in ${operationName}: ${error}`, "error");
      throw error;
    }
  }
};
ConflictPrevention.PLUGIN_ID = "youtube-clipper";
ConflictPrevention.CSS_PREFIX = "ytc";

// src/constants/messages.ts
var MESSAGES = {
  PROCESSING: "Processing YouTube video...",
  SUCCESS: (title) => `Successfully processed: ${title}`,
  OPENED_FILE: (filename) => `Opened: ${filename}`,
  ERRORS: {
    INVALID_URL: "Invalid YouTube URL. Please provide a valid YouTube video URL (e.g., https://www.youtube.com/watch?v=VIDEO_ID)",
    MISSING_API_KEYS: "No valid Gemini or Groq API key configured. Please set one in plugin settings.",
    GEMINI_INVALID_KEY: "Gemini API key is invalid or missing. Please check your key.",
    GROQ_MODEL_NOT_FOUND: "Groq API error: Model not found or you do not have access. Please check your API key and model name.",
    FETCH_VIDEO_DATA: (status) => `Failed to fetch video metadata: ${status}`,
    SAVE_FILE: (message) => `Failed to save file: ${message}`,
    AI_PROCESSING: (message) => `AI processing failed: ${message}`,
    FILE_NOT_EXISTS: "File no longer exists",
    COULD_NOT_OPEN: (message) => `Could not open file: ${message}`,
    ENTER_URL: "Please enter a YouTube URL",
    VIDEO_ID_EXTRACTION: "Could not extract video ID from URL. Please check the URL format.",
    NETWORK_ERROR: "Network error occurred. Please check your internet connection and try again."
  },
  WARNINGS: {
    CORS_RESTRICTIONS: "Description not available due to CORS restrictions",
    EXTRACTION_FAILED: "Description extraction failed",
    AUTO_EXTRACTION: "Video description could not be extracted automatically."
  },
  MODALS: {
    YOUTUBE_PROCESSED: "YouTube Video Processed",
    CONFIRM_OPEN: (filename) => `Successfully processed YouTube video and saved as "${filename}". Would you like to open the note now?`,
    CLOSE_CONFIRMATION: "Close without opening the note?",
    PROCESS_VIDEO: "Process YouTube Video",
    YES_OPEN: "Yes, open note",
    NO_THANKS: "No, thanks",
    CANCEL: "Cancel",
    PROCESS: "Process"
  },
  PLACEHOLDERS: {
    YOUTUBE_URL: "https://www.youtube.com/watch?v=...",
    GEMINI_KEY: "AIza...",
    GROQ_KEY: "gsk_...",
    OUTPUT_PATH: "YouTube/Processed Videos"
  }
};

// src/utils/validation.ts
var ValidationUtils = class {
  /**
   * Clean and normalize YouTube URL
   */
  static cleanYouTubeUrl(url) {
    if (!url || typeof url !== "string") {
      return "";
    }
    let cleanUrl = url.trim();
    cleanUrl = cleanUrl.replace(/[\u200B-\u200D\uFEFF]/g, "");
    if (!cleanUrl.startsWith("http://") && !cleanUrl.startsWith("https://")) {
      cleanUrl = "https://" + cleanUrl;
    }
    if (cleanUrl.startsWith("http://youtube.com") || cleanUrl.startsWith("http://www.youtube.com")) {
      cleanUrl = cleanUrl.replace("http://", "https://");
    }
    return cleanUrl;
  }
  /**
   * Extract YouTube video ID from URL (memoized for performance)
   * Enhanced extraction with better error handling
   */
  static extractVideoId(url) {
    if (!url || typeof url !== "string")
      return null;
    if (this.URL_CACHE.has(url)) {
      return this.URL_CACHE.get(url);
    }
    const cleanUrl = this.cleanYouTubeUrl(url);
    let result = null;
    let match = cleanUrl.match(this.URL_PATTERNS[0]);
    if ((match == null ? void 0 : match[1]) && this.VIDEO_ID_REGEX.test(match[1])) {
      result = match[1];
    } else {
      for (let i = 1; i < this.URL_PATTERNS.length && !result; i++) {
        match = cleanUrl.match(this.URL_PATTERNS[i]);
        if ((match == null ? void 0 : match[1]) && this.VIDEO_ID_REGEX.test(match[1])) {
          result = match[1];
        }
      }
    }
    if (this.URL_CACHE.size > 100) {
      this.URL_CACHE.clear();
    }
    this.URL_CACHE.set(url, result);
    if (!result) {
      console.warn("Failed to extract video ID from URL:", url);
    }
    return result;
  }
  /**
   * Validate YouTube URL format
   */
  static isValidYouTubeUrl(url) {
    return this.extractVideoId(url) !== null;
  }
  /**
   * Sanitize filename for file system compatibility
   */
  static sanitizeFilename(filename, maxLength = 100) {
    return filename.replace(/[<>:"/\\|?*]/g, "").replace(/\s+/g, " ").trim().substring(0, maxLength);
  }
  /**
   * Validate API key format
   */
  static isValidAPIKey(key, provider) {
    if (!key || typeof key !== "string") {
      return false;
    }
    switch (provider) {
      case "gemini":
        return key.startsWith("AIza") && key.length > 10;
      case "groq":
        return key.startsWith("gsk_") && key.length > 10;
      default:
        return false;
    }
  }
  /**
   * Validate settings configuration
   */
  static validateSettings(settings) {
    const errors = [];
    const usingEnv = Boolean(settings.useEnvironmentVariables);
    const hasDirectKey = this.isNonEmptyString(settings.geminiApiKey) || this.isNonEmptyString(settings.groqApiKey);
    if (!hasDirectKey && !usingEnv) {
      errors.push(MESSAGES.ERRORS.MISSING_API_KEYS);
    }
    if (this.isNonEmptyString(settings.geminiApiKey) && !this.isValidAPIKey(settings.geminiApiKey, "gemini")) {
      errors.push("Invalid Gemini API key format");
    }
    if (this.isNonEmptyString(settings.groqApiKey) && !this.isValidAPIKey(settings.groqApiKey, "groq")) {
      errors.push("Invalid Groq API key format");
    }
    if (usingEnv && !this.isNonEmptyString(settings.environmentPrefix)) {
      errors.push("Environment variable prefix is required when using environment variables");
    }
    if (!settings.outputPath || typeof settings.outputPath !== "string") {
      errors.push("Output path is required");
    }
    return {
      isValid: errors.length === 0,
      errors
    };
  }
  /**
   * Validate file path
   */
  static isValidPath(path) {
    return typeof path === "string" && path.trim().length > 0;
  }
  /**
   * Validate that a string is not empty
   */
  static isNonEmptyString(value) {
    return typeof value === "string" && value.trim().length > 0;
  }
  /**
   * Truncate text to specified length with ellipsis
   */
  static truncateText(text, maxLength) {
    if (text.length <= maxLength) {
      return text;
    }
    return text.substring(0, maxLength - 3) + "...";
  }
  /**
   * Clean HTML entities and escape sequences from text
   */
  static cleanText(text) {
    return text.replace(/\\n/g, "\n").replace(/\\"/g, '"').replace(/\\'/g, "'").replace(
      /\\u([0-9a-fA-F]{4})/g,
      (match, code) => String.fromCharCode(parseInt(code, 16))
    );
  }
};
/**
 * YouTube URL patterns for validation (ordered by frequency for performance)
 * Enhanced patterns to handle various YouTube URL formats
 */
ValidationUtils.URL_PATTERNS = [
  // Standard youtube.com/watch?v= format (most common)
  /(?:https?:\/\/)?(?:www\.)?youtube\.com\/watch\?v=([a-zA-Z0-9_-]{11})(?:&.*)?$/,
  // youtu.be short format (second most common)
  /(?:https?:\/\/)?(?:www\.)?youtu\.be\/([a-zA-Z0-9_-]{11})(?:\?.*)?$/,
  // youtube.com/embed format
  /(?:https?:\/\/)?(?:www\.)?youtube\.com\/embed\/([a-zA-Z0-9_-]{11})(?:\?.*)?$/,
  // youtube.com/v format
  /(?:https?:\/\/)?(?:www\.)?youtube\.com\/v\/([a-zA-Z0-9_-]{11})(?:\?.*)?$/,
  // Mobile youtube.com format
  /(?:https?:\/\/)?(?:m\.)?youtube\.com\/watch\?v=([a-zA-Z0-9_-]{11})(?:&.*)?$/
];
// Memoized regex for video ID validation (hot path optimization)
ValidationUtils.VIDEO_ID_REGEX = /^[a-zA-Z0-9_-]{11}$/;
ValidationUtils.URL_CACHE = /* @__PURE__ */ new Map();

// src/utils/error-handler.ts
var import_obsidian = require("obsidian");
var ErrorHandler = class {
  /**
   * Handle errors with consistent logging and user feedback
   */
  static handle(error, context, showNotice = true) {
    const errorMessage = `${context}: ${error.message}`;
    console.error(errorMessage, error);
    if (showNotice) {
      new import_obsidian.Notice(`Error: ${error.message}`);
    }
  }
  /**
   * Execute an operation with automatic error handling
   */
  static async withErrorHandling(operation, context, showNotice = true) {
    try {
      return await operation();
    } catch (error) {
      this.handle(error, context, showNotice);
      return null;
    }
  }
  /**
   * Execute a synchronous operation with error handling
   */
  static withSyncErrorHandling(operation, context, showNotice = true) {
    try {
      return operation();
    } catch (error) {
      this.handle(error, context, showNotice);
      return null;
    }
  }
  /**
   * Create a standardized error for API responses
   */
  static createAPIError(provider, status, statusText, details) {
    const message = `${provider} API error: ${status} ${statusText}${details ? `. ${details}` : ""}`;
    return new Error(message);
  }
  /**
   * Handle API response errors with consistent format
   */
  static async handleAPIError(response, provider, fallbackMessage) {
    var _a;
    let errorDetails = fallbackMessage || "";
    try {
      const errorData = await response.json();
      errorDetails = ((_a = errorData.error) == null ? void 0 : _a.message) || errorData.message || fallbackMessage || "";
    } catch (e) {
    }
    throw this.createAPIError(provider, response.status, response.statusText, errorDetails);
  }
  /**
   * Validate required configuration and throw descriptive errors
   */
  static validateConfiguration(config, requiredFields) {
    const missing = requiredFields.filter((field) => !config[field]);
    if (missing.length > 0) {
      throw new Error(`Missing required configuration: ${missing.join(", ")}`);
    }
  }
  /**
   * Create a user-friendly error message for common scenarios
   */
  static createUserFriendlyError(error, operation) {
    const message = `Failed to ${operation}: ${error.message}`;
    return new Error(message);
  }
  // Instance methods implementing interface
  handle(error, context, showNotice = true) {
    ErrorHandler.handle(error, context, showNotice);
  }
  async withErrorHandling(operation, context) {
    return ErrorHandler.withErrorHandling(operation, context);
  }
};

// src/components/modals/save-confirmation-modal.ts
var import_obsidian2 = require("obsidian");
var SaveConfirmationModal = class extends import_obsidian2.Modal {
  constructor(app, file, onConfirm) {
    super(app);
    this.file = file;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    try {
      contentEl.createEl("h2", { text: "Note created successfully. Open now?" });
      const buttonContainer = contentEl.createDiv("save-confirmation-buttons");
      new import_obsidian2.Setting(buttonContainer).addButton((btn) => btn.setButtonText("Open Note").setCta().onClick(() => {
        this.close();
        this.onConfirm(true);
      })).addButton((btn) => btn.setButtonText("Dismiss").onClick(() => {
        this.close();
        this.onConfirm(false);
      }));
      setTimeout(() => {
        const openButton = buttonContainer.querySelector("button");
        if (openButton) {
          openButton.focus();
        }
      }, 100);
    } catch (error) {
      console.error("[SaveConfirmationModal] Error in onOpen:", error);
      contentEl.createEl("h2", { text: "File Saved" });
      contentEl.createEl("p", { text: `File "${this.file.name}" has been saved successfully.` });
      contentEl.createEl("button", { text: "OK" }).onclick = () => this.close();
    }
  }
  /**
   * Get human-readable file size
   */
  getFileSize() {
    try {
      const stat = this.app.vault.adapter.stat(this.file.path);
      if (stat && typeof stat === "object" && "size" in stat) {
        const bytes = stat.size;
        if (bytes < 1024)
          return `${bytes} bytes`;
        if (bytes < 1024 * 1024)
          return `${(bytes / 1024).toFixed(1)} KB`;
        return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
      }
    } catch (error) {
    }
    return "";
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  /**
   * Add custom styles for the modal
   */
  addStyles() {
    var _a;
    const { contentEl } = this;
    contentEl.addClass("ytp-save-confirmation-modal");
    const style = document.createElement("style");
    style.textContent = `
            .ytp-save-confirmation-modal {
                min-width: 450px;
                max-width: 650px;
            }
            
            .save-confirmation-message {
                margin: 20px 0 30px 0;
                text-align: left;
                line-height: 1.6;
            }
            
            .save-confirmation-filename {
                font-weight: bold;
                font-size: 1.1em;
                margin-bottom: 15px;
                color: var(--text-accent);
                text-align: center;
            }
            
            .save-confirmation-location-container,
            .save-confirmation-size-container {
                margin-bottom: 10px;
                display: flex;
                align-items: center;
                gap: 8px;
            }
            
            .save-confirmation-location {
                font-family: var(--font-monospace);
                background: var(--background-secondary);
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 0.9em;
                word-break: break-all;
                color: var(--text-muted);
                flex: 1;
            }
            
            .save-confirmation-size {
                font-family: var(--font-monospace);
                background: var(--background-modifier-success);
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 0.9em;
                color: var(--text-on-accent);
            }
            
            .save-confirmation-buttons {
                text-align: center;
                margin-top: 20px;
                display: flex;
                justify-content: center;
                gap: 15px;
            }
            
            .save-confirmation-buttons .setting-item {
                border: none;
                padding: 0;
                margin: 0;
                display: flex;
                gap: 10px;
            }
            
            .save-confirmation-buttons button {
                min-width: 100px;
                padding: 8px 20px;
                font-size: 1em;
            }
            
            .save-confirmation-buttons button:first-child {
                /* Open File button - primary action */
                background-color: var(--interactive-accent);
                color: var(--text-on-accent);
            }
            
            .save-confirmation-buttons button:last-child {
                /* OK button - secondary action */
                background-color: var(--background-modifier-border);
                color: var(--text-normal);
            }
        `;
    document.head.appendChild(style);
    (_a = this.modalEl) == null ? void 0 : _a.setAttribute("data-style-id", "ytp-save-confirmation-style");
  }
};

// src/components/modals/youtube-url-modal.ts
var import_obsidian4 = require("obsidian");
init_base_modal();
init_api();
var YouTubeUrlModal = class extends BaseModal {
  constructor(app, options) {
    super(app);
    this.options = options;
    this.url = "";
    this.format = "executive-summary";
    this.fetchInProgress = false;
    this.progressSteps = [];
    this.currentStepIndex = 0;
    this.isProcessing = false;
    this.url = options.initialUrl || "";
  }
  onOpen() {
    this.createModalContent();
    this.setupEventHandlers();
    this.focusUrlInput();
  }
  /**
   * Create modal content
   */
  createModalContent() {
    this.headerEl = this.createHeader(MESSAGES.MODALS.PROCESS_VIDEO);
    this.createUrlInputSection();
    this.createFormatSelectionSection();
    this.createProviderSelectionSection();
    this.createProgressSection();
    this.createActionButtons();
  }
  createProviderSelectionSection() {
    const container = this.contentEl.createDiv();
    container.style.marginTop = "10px";
    const label = container.createEl("label", { text: "AI Provider & Model:" });
    label.setAttribute("for", "ytc-provider-select");
    const row = container.createDiv();
    row.style.display = "flex";
    row.style.gap = "8px";
    row.style.alignItems = "center";
    this.providerSelect = document.createElement("select");
    this.providerSelect.id = "ytc-provider-select";
    this.providerSelect.setAttribute("aria-label", "AI Provider");
    this.providerSelect.style.flex = "1";
    this.providerSelect.style.padding = "6px";
    this.providerSelect.style.borderRadius = "6px";
    this.providerSelect.style.border = "1px solid var(--background-modifier-border)";
    row.appendChild(this.providerSelect);
    this.modelSelect = document.createElement("select");
    this.modelSelect.id = "ytc-model-select";
    this.modelSelect.setAttribute("aria-label", "AI Model");
    this.modelSelect.style.width = "220px";
    this.modelSelect.style.padding = "6px";
    this.modelSelect.style.borderRadius = "6px";
    this.modelSelect.style.border = "1px solid var(--background-modifier-border)";
    row.appendChild(this.modelSelect);
    const providers = this.options.providers || [];
    const modelOptions = this.options.modelOptions || {};
    const autoOpt = document.createElement("option");
    autoOpt.value = "";
    autoOpt.text = "Auto (fallback)";
    this.providerSelect.appendChild(autoOpt);
    providers.forEach((p) => {
      const opt = document.createElement("option");
      opt.value = p;
      opt.text = p;
      this.providerSelect.appendChild(opt);
    });
    const refreshBtn = this.createInlineButton(row, "Refresh models", () => {
      void this.handleRefreshModels();
    });
    this.refreshSpinner = document.createElement("span");
    this.refreshSpinner.style.display = "none";
    this.refreshSpinner.style.marginLeft = "8px";
    this.refreshSpinner.style.width = "16px";
    this.refreshSpinner.style.height = "16px";
    this.refreshSpinner.style.border = "2px solid var(--background-modifier-border)";
    this.refreshSpinner.style.borderTop = "2px solid var(--interactive-accent)";
    this.refreshSpinner.style.borderRadius = "50%";
    this.refreshSpinner.style.animation = "ytp-spin 1s linear infinite";
    row.appendChild(this.refreshSpinner);
    this.providerSelect.addEventListener("change", () => {
      this.selectedProvider = this.providerSelect.value || void 0;
      this.populateModelsForProvider(this.selectedProvider || "", modelOptions, this.options.defaultModel);
    });
    if (this.options.defaultProvider) {
      this.providerSelect.value = this.options.defaultProvider;
      this.selectedProvider = this.options.defaultProvider;
    }
    this.populateModelsForProvider(this.selectedProvider || "", modelOptions, this.options.defaultModel);
  }
  async handleRefreshModels() {
    if (!this.options.fetchModels) {
      this.setValidationMessage("Model refresh not available.", "error");
      return;
    }
    this.setValidationMessage("Refreshing model lists\u2026", "info");
    if (this.refreshSpinner)
      this.refreshSpinner.style.display = "inline-block";
    try {
      const map = await this.options.fetchModels();
      const providers = Object.keys(map);
      if (this.providerSelect) {
        const current = this.providerSelect.value;
        this.providerSelect.innerHTML = "";
        const autoOpt = document.createElement("option");
        autoOpt.value = "";
        autoOpt.text = "Auto (fallback)";
        this.providerSelect.appendChild(autoOpt);
        providers.forEach((p) => {
          const opt = document.createElement("option");
          opt.value = p;
          opt.text = p;
          this.providerSelect.appendChild(opt);
        });
        if (current && Array.from(this.providerSelect.options).some((o) => o.value === current)) {
          this.providerSelect.value = current;
          this.selectedProvider = current;
        }
      }
      const modelOptions = map;
      this.populateModelsForProvider(this.selectedProvider || "", modelOptions, this.options.defaultModel);
      this.setValidationMessage("Model lists refreshed.", "success");
    } catch (error) {
      this.setValidationMessage("Failed to refresh models. Using cached options.", "error");
    } finally {
      if (this.refreshSpinner)
        this.refreshSpinner.style.display = "none";
    }
  }
  populateModelsForProvider(providerName, modelOptions, defaultModel) {
    if (!this.modelSelect)
      return;
    this.modelSelect.innerHTML = "";
    const models = modelOptions[providerName] || [];
    if (models.length === 0) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.text = "Default model";
      this.modelSelect.appendChild(opt);
      this.selectedModel = "";
      return;
    }
    models.forEach((m) => {
      const opt = document.createElement("option");
      opt.value = m;
      let label = m;
      try {
        const providerModels = PROVIDER_MODEL_OPTIONS[providerName] || [];
        const match = providerModels.find((pm) => {
          const name = typeof pm === "string" ? pm : pm && pm.name ? pm.name : "";
          return String(name).toLowerCase() === String(m).toLowerCase();
        });
        if (match && match.supportsAudioVideo) {
          label = `${m}  \u{1F3A5}`;
          opt.title = "Supports multimodal audio/video tokens";
        }
      } catch (err) {
      }
      opt.text = label;
      this.modelSelect.appendChild(opt);
    });
    if (defaultModel && models.includes(defaultModel)) {
      this.modelSelect.value = defaultModel;
      this.selectedModel = defaultModel;
    } else {
      this.modelSelect.selectedIndex = 0;
      this.selectedModel = this.modelSelect.value;
    }
    this.modelSelect.addEventListener("change", () => {
      this.selectedModel = this.modelSelect.value;
    });
  }
  /**
   * Create URL input section
   */
  createUrlInputSection() {
    const container = this.contentEl.createDiv();
    const label = container.createEl("label", { text: "YouTube URL:" });
    label.setAttribute("for", "ytc-url-input");
    const inputRow = container.createDiv();
    inputRow.style.display = "flex";
    inputRow.style.gap = "8px";
    inputRow.style.alignItems = "center";
    this.urlInput = this.createInput(
      inputRow,
      "url",
      MESSAGES.PLACEHOLDERS.YOUTUBE_URL + " (Press Enter to process)"
    );
    this.urlInput.id = "ytc-url-input";
    this.urlInput.setAttribute("aria-label", "YouTube URL");
    this.urlInput.setAttribute("aria-describedby", "ytc-url-hint");
    this.urlInput.style.flex = "1";
    this.urlInput.style.transition = "border-color 0.2s ease, box-shadow 0.2s ease";
    this.pasteButton = this.createInlineButton(inputRow, "Paste", () => {
      void this.handlePasteFromClipboard();
    });
    this.pasteButton.setAttribute("aria-label", "Paste YouTube URL from clipboard");
    this.clearButton = this.createInlineButton(inputRow, "Clear", () => {
      this.handleClearUrl();
    });
    this.clearButton.setAttribute("aria-label", "Clear YouTube URL input");
    if (this.options.initialUrl) {
      this.urlInput.value = this.options.initialUrl;
      this.url = this.options.initialUrl;
    }
    this.urlInput.addEventListener("input", (e) => {
      this.url = e.target.value;
      this.updateProcessButtonState();
      this.updateQuickActionsState();
    });
    this.validationMessage = container.createDiv();
    this.validationMessage.id = "ytc-url-hint";
    this.validationMessage.style.marginTop = "6px";
    this.validationMessage.style.fontSize = "0.85rem";
    this.validationMessage.style.color = "var(--text-muted)";
    this.validationMessage.setAttribute("role", "status");
    this.setValidationMessage("Paste a YouTube link to begin processing.", "info");
    const preview = container.createDiv();
    preview.style.display = "flex";
    preview.style.gap = "10px";
    preview.style.alignItems = "center";
    preview.style.marginTop = "8px";
    this.thumbnailEl = preview.createEl("img");
    this.thumbnailEl.setAttribute("aria-label", "Video thumbnail");
    this.thumbnailEl.style.width = "120px";
    this.thumbnailEl.style.height = "68px";
    this.thumbnailEl.style.objectFit = "cover";
    this.thumbnailEl.style.borderRadius = "4px";
    this.thumbnailEl.style.display = "none";
    this.metadataContainer = preview.createDiv();
    this.metadataContainer.setAttribute("aria-label", "Video metadata");
    this.metadataContainer.style.display = "none";
    this.metadataContainer.style.fontSize = "0.9rem";
    this.metadataContainer.style.color = "var(--text-normal)";
    this.metadataContainer.createDiv({ cls: "yt-preview-title" });
    this.metadataContainer.createDiv({ cls: "yt-preview-channel" });
    this.setUrlInputState("idle");
    this.updateQuickActionsState();
  }
  /**
   * Create format selection section with radio buttons
   */
  createFormatSelectionSection() {
    const container = this.contentEl.createDiv();
    const label = container.createEl("label", { text: "Output Format:" });
    label.id = "format-group-label";
    const radioContainer = container.createDiv();
    radioContainer.setAttribute("role", "group");
    radioContainer.setAttribute("aria-labelledby", "format-group-label");
    radioContainer.style.marginTop = "8px";
    radioContainer.style.display = "flex";
    radioContainer.style.gap = "20px";
    const executiveContainer = radioContainer.createDiv();
    executiveContainer.style.display = "flex";
    executiveContainer.style.alignItems = "center";
    executiveContainer.style.gap = "8px";
    const executiveRadio = executiveContainer.createEl("input");
    executiveRadio.type = "radio";
    executiveRadio.name = "outputFormat";
    executiveRadio.value = "executive-summary";
    executiveRadio.id = "executive-radio";
    executiveRadio.checked = this.format === "executive-summary";
    executiveRadio.setAttribute("aria-label", "Executive Summary format");
    const executiveLabel = executiveContainer.createEl("label");
    executiveLabel.setAttribute("for", "executive-radio");
    executiveLabel.textContent = "Executive";
    executiveLabel.style.cursor = "pointer";
    const tutorialContainer = radioContainer.createDiv();
    tutorialContainer.style.display = "flex";
    tutorialContainer.style.alignItems = "center";
    tutorialContainer.style.gap = "8px";
    const tutorialRadio = tutorialContainer.createEl("input");
    tutorialRadio.type = "radio";
    tutorialRadio.name = "outputFormat";
    tutorialRadio.value = "detailed-guide";
    tutorialRadio.id = "tutorial-radio";
    tutorialRadio.checked = this.format === "detailed-guide";
    tutorialRadio.setAttribute("aria-label", "Detailed Guide format");
    const tutorialLabel = tutorialContainer.createEl("label");
    tutorialLabel.setAttribute("for", "tutorial-radio");
    tutorialLabel.textContent = "Tutorial";
    tutorialLabel.style.cursor = "pointer";
    executiveRadio.addEventListener("change", (e) => {
      if (e.target.checked) {
        this.format = "executive-summary";
      }
    });
    tutorialRadio.addEventListener("change", (e) => {
      if (e.target.checked) {
        this.format = "detailed-guide";
      }
    });
    const briefContainer = radioContainer.createDiv();
    briefContainer.style.display = "flex";
    briefContainer.style.alignItems = "center";
    briefContainer.style.gap = "8px";
    const briefRadio = briefContainer.createEl("input");
    briefRadio.type = "radio";
    briefRadio.name = "outputFormat";
    briefRadio.value = "brief";
    briefRadio.id = "brief-radio";
    briefRadio.checked = this.format === "brief";
    briefRadio.setAttribute("aria-label", "Brief format");
    const briefLabel = briefContainer.createEl("label");
    briefLabel.setAttribute("for", "brief-radio");
    briefLabel.textContent = "Brief";
    briefLabel.style.cursor = "pointer";
    briefRadio.addEventListener("change", (e) => {
      if (e.target.checked) {
        this.format = "brief";
      }
    });
  }
  /**
   * Create progress section
   */
  createProgressSection() {
    this.progressContainer = this.contentEl.createDiv();
    this.progressContainer.setAttribute("role", "region");
    this.progressContainer.setAttribute("aria-label", "Processing progress");
    this.progressContainer.setAttribute("aria-live", "polite");
    this.progressContainer.style.marginTop = "16px";
    this.progressContainer.style.display = "none";
    this.progressText = this.progressContainer.createDiv();
    this.progressText.id = "progress-text";
    this.progressText.style.marginBottom = "8px";
    this.progressText.style.fontWeight = "500";
    this.progressText.style.color = "var(--text-accent)";
    this.progressText.textContent = "Processing video...";
    const progressBarContainer = this.progressContainer.createDiv();
    progressBarContainer.setAttribute("role", "progressbar");
    progressBarContainer.setAttribute("aria-valuenow", "0");
    progressBarContainer.setAttribute("aria-valuemin", "0");
    progressBarContainer.setAttribute("aria-valuemax", "100");
    progressBarContainer.setAttribute("aria-labelledby", "progress-text");
    progressBarContainer.style.width = "100%";
    progressBarContainer.style.height = "6px";
    progressBarContainer.style.backgroundColor = "var(--background-modifier-border)";
    progressBarContainer.style.borderRadius = "3px";
    progressBarContainer.style.overflow = "hidden";
    this.progressBar = progressBarContainer.createDiv();
    this.progressBar.style.height = "100%";
    this.progressBar.style.backgroundColor = "var(--text-accent)";
    this.progressBar.style.borderRadius = "3px";
    this.progressBar.style.width = "0%";
    this.progressBar.style.transition = "width 0.3s ease";
    const stepList = this.progressContainer.createEl("ol");
    stepList.setAttribute("aria-label", "Processing steps");
    stepList.style.marginTop = "12px";
    stepList.style.paddingLeft = "20px";
    stepList.style.fontSize = "0.9rem";
    stepList.style.color = "var(--text-normal)";
    const labels = [
      "Validate URL",
      "Fetch video info",
      "Run AI analysis",
      "Save note"
    ];
    this.progressSteps = labels.map((label) => {
      const item = stepList.createEl("li");
      item.setAttribute("role", "status");
      item.style.marginBottom = "4px";
      item.textContent = `\u25CB ${label}`;
      return { label, element: item };
    });
  }
  /**
   * Create action buttons with accessibility
   */
  createActionButtons() {
    const container = this.createButtonContainer();
    const cancelBtn = this.createButton(
      container,
      MESSAGES.MODALS.CANCEL,
      false,
      () => this.close()
    );
    cancelBtn.setAttribute("aria-label", "Cancel video processing");
    this.processButton = this.createButton(
      container,
      MESSAGES.MODALS.PROCESS,
      true,
      () => this.handleProcess()
    );
    this.processButton.setAttribute("aria-label", "Process YouTube video");
    this.openButton = this.createButton(
      container,
      "Open Note",
      true,
      () => this.handleOpenFile()
    );
    this.openButton.setAttribute("aria-label", "Open the processed note");
    this.openButton.style.display = "none";
    this.updateProcessButtonState();
  }
  /**
   * Set up event handlers
   */
  setupEventHandlers() {
    this.setupKeyHandlers(
      () => this.handleProcess(),
      () => this.close()
    );
  }
  /**
   * Focus on URL input
   */
  focusUrlInput() {
    if (this.urlInput) {
      this.focusElement(this.urlInput);
    }
  }
  /**
   * Update process button enabled state (optimized with debouncing and memoization)
   */
  updateProcessButtonState() {
    if (!this.processButton)
      return;
    if (this.isProcessing) {
      return;
    }
    const trimmedUrl = this.url.trim();
    if (this.processButton && this.processButton.textContent !== MESSAGES.MODALS.PROCESS && trimmedUrl.length >= 0) {
      this.processButton.textContent = MESSAGES.MODALS.PROCESS;
    }
    if (trimmedUrl === this.lastValidUrl) {
      const isValid = this.lastValidResult;
      this.processButton.disabled = !isValid;
      this.processButton.style.opacity = isValid ? "1" : "0.5";
      if (trimmedUrl.length === 0) {
        this.setValidationMessage("Paste a YouTube link to begin processing.", "info");
        this.setUrlInputState("idle");
      } else {
        this.setValidationMessage(
          isValid ? "Ready to process this video." : "Enter a valid YouTube video URL.",
          isValid ? "success" : "error"
        );
        this.setUrlInputState(isValid ? "valid" : "invalid");
      }
      this.updateQuickActionsState();
      return;
    }
    if (this.validationTimer) {
      clearTimeout(this.validationTimer);
    }
    this.validationTimer = window.setTimeout(() => {
      const isValid = ValidationUtils.isValidYouTubeUrl(trimmedUrl);
      this.lastValidUrl = trimmedUrl;
      this.lastValidResult = isValid;
      this.processButton.disabled = !isValid;
      this.processButton.style.opacity = isValid ? "1" : "0.5";
      if (trimmedUrl.length === 0) {
        this.setValidationMessage("Paste a YouTube link to begin processing.", "info");
        this.setUrlInputState("idle");
      } else {
        this.setValidationMessage(
          isValid ? "Ready to process this video." : "Enter a valid YouTube video URL.",
          isValid ? "success" : "error"
        );
        this.setUrlInputState(isValid ? "valid" : "invalid");
      }
      this.updateQuickActionsState();
      if (isValid) {
        void this.maybeFetchPreview(trimmedUrl);
      } else {
        this.clearPreview();
      }
    }, 300);
  }
  /**
   * Validate URL input (simplified - used by debounced handler)
   */
  isUrlValid() {
    return ValidationUtils.isValidYouTubeUrl(this.url.trim());
  }
  /**
   * Handle process button click
   */
  async handleProcess() {
    const trimmedUrl = this.url.trim();
    if (!trimmedUrl) {
      new import_obsidian4.Notice(MESSAGES.ERRORS.ENTER_URL);
      this.focusUrlInput();
      return;
    }
    if (!this.isUrlValid()) {
      new import_obsidian4.Notice(MESSAGES.ERRORS.INVALID_URL);
      this.focusUrlInput();
      return;
    }
    try {
      if (this.selectedProvider === "Google Gemini" && this.selectedModel && this.isUrlValid()) {
        try {
          const models = PROVIDER_MODEL_OPTIONS["Google Gemini"] || [];
          const match = models.find((m) => {
            const name = typeof m === "string" ? m : m && m.name ? m.name : "";
            return String(name).toLowerCase() === String(this.selectedModel || "").toLowerCase();
          });
          const supportsAudioVideo = !!(match && match.supportsAudioVideo);
          if (!supportsAudioVideo) {
            const recommended = (models.find((m) => m && m.supportsAudioVideo) || { name: AI_MODELS.GEMINI }).name;
            const shouldSwitch = await this.showConfirmationModal(
              "Multimodal Model Recommended",
              `The selected model (${this.selectedModel}) may not support multimodal analysis.

Would you like to switch to a multimodal-capable model (${recommended}) for better video analysis?`,
              "Switch to Multimodal",
              "Keep Current Model",
              false
            );
            if (shouldSwitch) {
              if (this.modelSelect) {
                const exists = Array.from(this.modelSelect.options).some((o) => o.value === recommended);
                if (!exists) {
                  const opt = document.createElement("option");
                  opt.value = recommended;
                  opt.text = recommended;
                  this.modelSelect.appendChild(opt);
                }
                this.modelSelect.value = recommended;
                this.selectedModel = recommended;
              } else {
                this.selectedModel = recommended;
              }
            }
          }
        } catch (err) {
          console.warn("[YouTubeUrlModal] model recommendation failed", err);
        }
      }
      this.showProcessingState();
      this.setStepState(0, "active");
      this.updateProgress(20, "Validating YouTube URL...");
      await new Promise((resolve) => setTimeout(resolve, 500));
      this.setStepState(0, "complete");
      this.setStepState(1, "active");
      this.updateProgress(40, "Extracting video data...");
      await new Promise((resolve) => setTimeout(resolve, 500));
      this.setStepState(1, "complete");
      this.setStepState(2, "active");
      this.updateProgress(60, "Analyzing video content...");
      const filePath = await this.options.onProcess(
        trimmedUrl,
        this.format,
        this.selectedProvider,
        this.selectedModel
      );
      this.setStepState(2, "complete");
      this.setStepState(3, "active");
      this.updateProgress(80, "Generating note...");
      await new Promise((resolve) => setTimeout(resolve, 300));
      this.updateProgress(100, "Complete!");
      this.setStepState(3, "complete");
      this.processedFilePath = filePath;
      this.showCompletionState();
    } catch (error) {
      this.flagActiveStepAsError();
      this.showErrorState(error);
      ErrorHandler.handle(error, "YouTube URL processing");
    }
  }
  /**
   * Handle open file button click
   */
  async handleOpenFile() {
    if (this.processedFilePath && this.options.onOpenFile) {
      try {
        await this.options.onOpenFile(this.processedFilePath);
        this.close();
      } catch (error) {
        ErrorHandler.handle(error, "Opening file");
      }
    }
  }
  /**
   * Show processing state
   */
  showProcessingState() {
    this.isProcessing = true;
    this.setValidationMessage("Processing video. This may take a moment...", "info");
    this.resetProgressSteps();
    if (this.progressContainer) {
      this.progressContainer.style.display = "block";
    }
    if (this.urlInput) {
      this.urlInput.disabled = true;
    }
    if (this.processButton) {
      this.processButton.disabled = true;
      this.processButton.textContent = "Processing...";
    }
    if (this.openButton) {
      this.openButton.style.display = "none";
    }
    this.setUrlInputState("idle");
    this.updateQuickActionsState();
  }
  /**
   * Show completion state
   */
  showCompletionState() {
    this.isProcessing = false;
    if (this.progressContainer) {
      this.progressContainer.style.display = "none";
    }
    if (this.urlInput) {
      this.urlInput.disabled = false;
    }
    if (this.processButton) {
      this.processButton.disabled = false;
      this.processButton.textContent = "Process Another";
      this.processButton.style.display = "inline-block";
      this.processButton.style.opacity = "1";
    }
    if (this.openButton) {
      this.openButton.style.display = "inline-block";
    }
    if (this.headerEl) {
      this.headerEl.textContent = "\u2705 Video Processed Successfully!";
    }
    this.setValidationMessage("Note saved to today's folder. You can open it now or process another video.", "success");
    this.focusUrlInput();
    this.updateQuickActionsState();
    this.setUrlInputState(this.url.trim().length > 0 ? "valid" : "idle");
  }
  /**
   * Show error state
   */
  showErrorState(error) {
    this.isProcessing = false;
    if (this.progressContainer) {
      this.progressContainer.style.display = "none";
    }
    if (this.urlInput) {
      this.urlInput.disabled = false;
    }
    if (this.processButton) {
      this.processButton.disabled = false;
      this.processButton.textContent = MESSAGES.MODALS.PROCESS;
      this.processButton.style.display = "inline-block";
    }
    if (this.openButton) {
      this.openButton.style.display = "none";
    }
    if (this.headerEl) {
      this.headerEl.textContent = "\u274C Processing Failed";
    }
    this.setValidationMessage(error.message, "error");
    this.updateQuickActionsState();
    this.setUrlInputState(this.url.trim().length > 0 ? "invalid" : "idle");
  }
  /**
   * Update progress bar and text
   */
  updateProgress(percent, text) {
    if (this.progressBar) {
      this.progressBar.style.width = `${percent}%`;
    }
    if (this.progressText) {
      this.progressText.textContent = text;
    }
  }
  /**
   * Set initial URL value
   */
  setUrl(url) {
    this.url = url;
    if (this.urlInput) {
      this.urlInput.value = url;
      this.updateProcessButtonState();
      this.updateQuickActionsState();
      const trimmed = url.trim();
      if (trimmed.length === 0) {
        this.setUrlInputState("idle");
      } else {
        this.setUrlInputState(ValidationUtils.isValidYouTubeUrl(trimmed) ? "valid" : "invalid");
      }
    }
  }
  /**
   * Clean up resources when modal is closed
   */
  onClose() {
    if (this.validationTimer) {
      clearTimeout(this.validationTimer);
      this.validationTimer = void 0;
    }
    super.onClose();
  }
  /**
   * Get current URL value
   */
  getUrl() {
    return this.url;
  }
  resetProgressSteps() {
    this.currentStepIndex = 0;
    if (this.progressSteps.length === 0) {
      return;
    }
    this.progressSteps.forEach((step) => {
      step.element.textContent = `\u25CB ${step.label}`;
    });
  }
  setStepState(index, state) {
    const target = this.progressSteps[index];
    if (!target) {
      return;
    }
    const prefix = this.getStepPrefix(state);
    target.element.textContent = `${prefix} ${target.label}`;
    if (state === "active") {
      this.currentStepIndex = index;
    } else if (state === "complete" && this.currentStepIndex === index) {
      this.currentStepIndex = Math.min(index + 1, this.progressSteps.length - 1);
    }
  }
  flagActiveStepAsError() {
    if (this.progressSteps.length === 0) {
      return;
    }
    this.setStepState(this.currentStepIndex, "error");
  }
  getStepPrefix(state) {
    switch (state) {
      case "active":
        return "\u25CF";
      case "complete":
        return "\u2714";
      case "error":
        return "\u26A0";
      default:
        return "\u25CB";
    }
  }
  createInlineButton(container, label, onClick) {
    const button = container.createEl("button", { text: label });
    button.style.padding = "6px 12px";
    button.style.fontSize = "0.85rem";
    button.style.borderRadius = "6px";
    button.style.border = "1px solid var(--background-modifier-border)";
    button.style.backgroundColor = "var(--background-primary)";
    button.style.color = "var(--text-normal)";
    button.style.cursor = "pointer";
    button.style.transition = "background-color 0.2s ease";
    button.addEventListener("mouseenter", () => {
      button.style.backgroundColor = "var(--background-modifier-hover)";
    });
    button.addEventListener("mouseleave", () => {
      button.style.backgroundColor = "var(--background-primary)";
    });
    button.addEventListener("click", onClick);
    return button;
  }
  async handlePasteFromClipboard() {
    if (this.isProcessing) {
      return;
    }
    if (!navigator.clipboard || !navigator.clipboard.readText) {
      this.setValidationMessage("Clipboard access is not available in this environment.", "error");
      new import_obsidian4.Notice("Clipboard access is not available.");
      return;
    }
    try {
      const text = await navigator.clipboard.readText();
      if (!text) {
        this.setValidationMessage("Clipboard is empty. Copy a YouTube URL first.", "info");
        return;
      }
      const trimmed = text.trim();
      this.url = trimmed;
      if (this.urlInput) {
        this.urlInput.value = trimmed;
      }
      this.lastValidUrl = void 0;
      this.updateProcessButtonState();
      this.updateQuickActionsState();
      const isValid = ValidationUtils.isValidYouTubeUrl(trimmed);
      this.setValidationMessage(
        isValid ? "Ready to process this video." : "Enter a valid YouTube video URL.",
        isValid ? "success" : "error"
      );
      this.setUrlInputState(isValid ? "valid" : "invalid");
      if (this.processButton && !this.isProcessing && isValid) {
        this.processButton.focus();
      } else {
        this.focusUrlInput();
      }
    } catch (error) {
      ErrorHandler.handle(error, "Reading clipboard", false);
      this.setValidationMessage("Could not read from clipboard. Paste manually instead.", "error");
      new import_obsidian4.Notice("Could not read from clipboard.");
    }
  }
  handleClearUrl() {
    if (this.isProcessing) {
      return;
    }
    this.url = "";
    if (this.urlInput) {
      this.urlInput.value = "";
    }
    this.lastValidUrl = void 0;
    this.updateProcessButtonState();
    this.updateQuickActionsState();
    this.setValidationMessage("Paste a YouTube link to begin processing.", "info");
    this.setUrlInputState("idle");
    this.focusUrlInput();
  }
  updateQuickActionsState() {
    const hasUrl = this.url.trim().length > 0;
    if (this.clearButton) {
      this.clearButton.disabled = !hasUrl || this.isProcessing;
      this.clearButton.style.opacity = this.clearButton.disabled ? "0.5" : "1";
    }
    if (this.pasteButton) {
      this.pasteButton.disabled = this.isProcessing;
      this.pasteButton.style.opacity = this.pasteButton.disabled ? "0.5" : "1";
    }
  }
  setUrlInputState(state) {
    if (!this.urlInput) {
      return;
    }
    let borderColor = "var(--background-modifier-border)";
    let boxShadow = "none";
    if (state === "valid") {
      borderColor = "var(--text-accent)";
      boxShadow = "0 0 0 1px var(--text-accent)";
    } else if (state === "invalid") {
      borderColor = "var(--text-error)";
      boxShadow = "0 0 0 1px var(--text-error)";
    }
    this.urlInput.style.borderColor = borderColor;
    this.urlInput.style.boxShadow = boxShadow;
  }
  setValidationMessage(message, type) {
    if (!this.validationMessage) {
      return;
    }
    this.validationMessage.textContent = message;
    let color = "var(--text-muted)";
    if (type === "error") {
      color = "var(--text-error)";
    } else if (type === "success") {
      color = "var(--text-accent)";
    } else {
      color = "var(--text-muted)";
    }
    this.validationMessage.style.color = color;
  }
  /**
   * Try to fetch a lightweight preview for the provided YouTube URL using oEmbed.
   */
  async maybeFetchPreview(url) {
    if (this.fetchInProgress)
      return;
    if (!url)
      return;
    if (this.lastValidUrl === url && this.thumbnailEl && this.thumbnailEl.style.display === "block") {
      return;
    }
    this.setFetchingState(true);
    try {
      const meta = await this.fetchVideoPreview(url);
      if (meta) {
        this.showPreview(meta);
      } else {
        this.clearPreview();
      }
    } catch (error) {
      this.clearPreview();
    } finally {
      this.setFetchingState(false);
    }
  }
  setFetchingState(isFetching) {
    var _a;
    this.fetchInProgress = isFetching;
    if (this.processButton) {
      this.processButton.disabled = isFetching || !((_a = this.lastValidResult) != null ? _a : false);
      this.processButton.style.opacity = this.processButton.disabled ? "0.5" : "1";
    }
    if (this.validationMessage) {
      if (isFetching)
        this.setValidationMessage("Fetching preview...", "info");
      else if (this.lastValidResult)
        this.setValidationMessage("Ready to process this video.", "success");
      else
        this.setValidationMessage("Enter a valid YouTube video URL.", "error");
    }
  }
  async fetchVideoPreview(url) {
    try {
      const oembed = `https://www.youtube.com/oembed?url=${encodeURIComponent(url)}&format=json`;
      const res = await fetch(oembed);
      if (!res.ok)
        return null;
      const data = await res.json();
      return {
        title: data.title || "",
        author: data.author_name || "",
        thumbnail: data.thumbnail_url || ""
      };
    } catch (error) {
      return null;
    }
  }
  showPreview(meta) {
    if (!this.thumbnailEl || !this.metadataContainer)
      return;
    if (meta.thumbnail) {
      this.thumbnailEl.src = meta.thumbnail;
      this.thumbnailEl.style.display = "block";
    } else {
      this.thumbnailEl.style.display = "none";
    }
    const titleEl = this.metadataContainer.querySelector(".yt-preview-title");
    const channelEl = this.metadataContainer.querySelector(".yt-preview-channel");
    if (titleEl) {
      titleEl.textContent = meta.title;
      titleEl.style.fontWeight = "600";
      titleEl.style.marginBottom = "4px";
    }
    if (channelEl) {
      channelEl.textContent = meta.author;
      channelEl.style.color = "var(--text-muted)";
      channelEl.style.fontSize = "0.85rem";
    }
    this.metadataContainer.style.display = "block";
  }
  clearPreview() {
    if (this.thumbnailEl) {
      this.thumbnailEl.src = "";
      this.thumbnailEl.style.display = "none";
    }
    if (this.metadataContainer) {
      const titleEl = this.metadataContainer.querySelector(".yt-preview-title");
      const channelEl = this.metadataContainer.querySelector(".yt-preview-channel");
      if (titleEl)
        titleEl.textContent = "";
      if (channelEl)
        channelEl.textContent = "";
      this.metadataContainer.style.display = "none";
    }
  }
};

// src/components/settings/settings-tab.ts
var import_obsidian5 = require("obsidian");

// src/services/secure-config.ts
var SecureConfigService = class {
  constructor(settings) {
    this.settings = settings;
  }
  /**
   * Get API key with environment variable fallback
   */
  getApiKey(keyType) {
    if (this.settings.useEnvironmentVariables) {
      return this.getFromEnvironment(keyType);
    }
    return keyType === "gemini" ? this.settings.geminiApiKey : this.settings.groqApiKey;
  }
  /**
   * Get API key from environment variables
   */
  getFromEnvironment(keyType) {
    const prefix = this.settings.environmentPrefix || "YTC";
    const envVarName = `${prefix}_${keyType.toUpperCase()}_API_KEY`;
    return this.getSecureEnvVar(envVarName) || "";
  }
  /**
   * Secure environment variable access
   * Note: In Obsidian plugins, environment variables are limited
   * This method can be extended for server-side environments
   */
  getSecureEnvVar(varName) {
    if (typeof process !== "undefined" && process.env) {
      return process.env[varName];
    }
    return this.getFromSecureStorage(varName);
  }
  /**
   * Get from secure storage (implementation depends on environment)
   */
  getFromSecureStorage(varName) {
    return void 0;
  }
  /**
   * Validate configuration security
   */
  validateSecurityConfiguration() {
    const warnings = [];
    let isSecure = true;
    if (!this.settings.useEnvironmentVariables) {
      if (this.settings.geminiApiKey && this.settings.geminiApiKey.length > 0) {
        warnings.push("Gemini API key is stored directly in configuration. Consider using environment variables.");
        isSecure = false;
      }
      if (this.settings.groqApiKey && this.settings.groqApiKey.length > 0) {
        warnings.push("Groq API key is stored directly in configuration. Consider using environment variables.");
        isSecure = false;
      }
    }
    if (this.settings.geminiApiKey === "your-api-key-here" || this.settings.groqApiKey === "your-api-key-here") {
      warnings.push("Default placeholder API keys detected. Please set real API keys.");
      isSecure = false;
    }
    return { isSecure, warnings };
  }
  /**
   * Get configuration template for environment variables
   */
  getEnvironmentTemplate() {
    const prefix = this.settings.environmentPrefix || "YTC";
    return `# YouTubeClipper Environment Variables
# Set these in your environment for secure API key management

# Google Gemini API Key
${prefix}_GEMINI_API_KEY=your_gemini_api_key_here

# Groq API Key  
${prefix}_GROQ_API_KEY=your_groq_api_key_here

# Usage:
# 1. Set these variables in your shell profile (.bashrc, .zshrc, etc.)
# 2. Enable "Use Environment Variables" in plugin settings
# 3. Restart Obsidian to pick up the new environment variables
`;
  }
};

// src/components/settings/settings-tab.ts
var SETTINGS_CSS_CLASSES = {
  container: "ytc-settings-container",
  section: "ytc-settings-section",
  header: "ytc-settings-header",
  validation: "ytc-settings-validation"
};
var YouTubeSettingsTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, options) {
    super(app, options.plugin);
    this.options = options;
    this.validationErrors = [];
    this.settings = { ...options.plugin.settings };
    this.secureConfig = new SecureConfigService(this.settings);
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass(SETTINGS_CSS_CLASSES.container);
    containerEl.setAttribute("data-plugin", "youtube-clipper");
    this.createHeader();
    this.createAPISettings();
    this.createSecuritySettings();
    this.createFileSettings();
    this.createValidationStatus();
    this.createUsageInstructions();
  }
  /**
   * Create header with version information
   */
  createHeader() {
    const headerEl = this.containerEl.createDiv(SETTINGS_CSS_CLASSES.header);
    headerEl.createEl("h2", { text: "YouTubeClipper Settings" });
    const versionEl = headerEl.createDiv("ytc-version-info");
    versionEl.createEl("span", {
      text: "v1.2.0 - Production Ready",
      cls: "ytc-version-badge"
    });
    const statusEl = headerEl.createDiv("ytc-status-info");
    const hasValidConfig = this.validateConfiguration();
    statusEl.createEl("span", {
      text: hasValidConfig ? "\u2705 Ready to use" : "\u26A0\uFE0F Configuration needed",
      cls: hasValidConfig ? "ytc-status-good" : "ytc-status-warning"
    });
    const docsEl = headerEl.createDiv("ytc-docs-link");
    docsEl.createEl("a", {
      text: "\u{1F4D6} View Documentation",
      href: "#",
      cls: "ytc-docs-button"
    }).addEventListener("click", (e) => {
      e.preventDefault();
      this.showDocumentation();
    });
  }
  /**
   * Validate entire configuration
   */
  validateConfiguration() {
    var _a, _b;
    const hasApiKey = ((_a = this.settings.geminiApiKey) == null ? void 0 : _a.trim()) || ((_b = this.settings.groqApiKey) == null ? void 0 : _b.trim());
    const hasValidPath = ValidationUtils.isValidPath(this.settings.outputPath);
    return Boolean(hasApiKey && hasValidPath);
  }
  /**
   * Show inline documentation
   */
  showDocumentation() {
    window.open("https://github.com/youtube-clipper/obsidian-plugin#readme", "_blank");
  }
  /**
  * Create API configuration settings
  */
  createAPISettings() {
    const { containerEl } = this;
    containerEl.createEl("h3", { text: "API Configuration" });
    new import_obsidian5.Setting(containerEl).setName("Gemini API Key").setDesc("Your Google Gemini API key for content processing (recommended)").addText((text) => text.setPlaceholder(MESSAGES.PLACEHOLDERS.GEMINI_KEY).setValue(this.settings.geminiApiKey).onChange(async (value) => {
      await this.updateSetting("geminiApiKey", value);
    }));
    new import_obsidian5.Setting(containerEl).setName("Groq API Key").setDesc("Your Groq API key for fallback processing").addText((text) => text.setPlaceholder(MESSAGES.PLACEHOLDERS.GROQ_KEY).setValue(this.settings.groqApiKey).onChange(async (value) => {
      await this.updateSetting("groqApiKey", value);
    }));
  }
  /**
   * Create security configuration settings
   */
  createSecuritySettings() {
    const { containerEl } = this;
    containerEl.createEl("h3", { text: "Security Configuration" });
    new import_obsidian5.Setting(containerEl).setName("Use Environment Variables").setDesc("Load API keys from environment variables instead of storing them in configuration").addToggle((toggle) => toggle.setValue(this.settings.useEnvironmentVariables || false).onChange(async (value) => {
      await this.updateSetting("useEnvironmentVariables", value);
      this.display();
    }));
    if (this.settings.useEnvironmentVariables) {
      new import_obsidian5.Setting(containerEl).setName("Environment Variable Prefix").setDesc("Prefix for environment variable names (e.g., YTC_GEMINI_API_KEY)").addText((text) => text.setPlaceholder("YTC").setValue(this.settings.environmentPrefix || "YTC").onChange(async (value) => {
        await this.updateSetting("environmentPrefix", value || "YTC");
      }));
      const envTemplate = this.secureConfig.getEnvironmentTemplate();
      const envSection = containerEl.createDiv("ytc-env-template");
      envSection.createEl("h4", { text: "Environment Variables Template" });
      envSection.createEl("p", {
        text: "Copy these environment variables to your shell profile:",
        cls: "setting-item-description"
      });
      const preEl = envSection.createEl("pre");
      preEl.createEl("code", { text: envTemplate });
      new import_obsidian5.Setting(envSection).setName("Copy Template").setDesc("Copy the environment variables template to clipboard").addButton((button) => button.setButtonText("Copy to Clipboard").onClick(() => {
        navigator.clipboard.writeText(envTemplate);
        button.setButtonText("Copied!");
        setTimeout(() => button.setButtonText("Copy to Clipboard"), 2e3);
      }));
    }
    const validation = this.secureConfig.validateSecurityConfiguration();
    if (!validation.isSecure) {
      const warningEl = containerEl.createDiv("ytc-security-warnings");
      warningEl.createEl("h4", { text: "\u26A0\uFE0F Security Warnings", cls: "ytc-warning-header" });
      validation.warnings.forEach((warning) => {
        warningEl.createEl("p", { text: warning, cls: "ytc-warning-text" });
      });
    }
  }
  /**
   * Create file configuration settings
   */
  createFileSettings() {
    const { containerEl } = this;
    containerEl.createEl("h3", { text: "File Configuration" });
    new import_obsidian5.Setting(containerEl).setName("Output Path").setDesc("Directory path where processed videos will be saved (relative to vault root)").addText((text) => text.setPlaceholder(MESSAGES.PLACEHOLDERS.OUTPUT_PATH).setValue(this.settings.outputPath).onChange(async (value) => {
      await this.updateSetting("outputPath", value);
    }));
  }
  /**
   * Create validation status display
   */
  createValidationStatus() {
    const { containerEl } = this;
    if (this.validationErrors.length > 0) {
      const errorSection = containerEl.createDiv();
      errorSection.style.marginTop = "20px";
      errorSection.style.padding = "10px";
      errorSection.style.backgroundColor = "var(--background-modifier-error)";
      errorSection.style.borderRadius = "4px";
      errorSection.createEl("h4", {
        text: "\u26A0\uFE0F Configuration Issues",
        attr: { style: "color: var(--text-error); margin-top: 0;" }
      });
      const errorList = errorSection.createEl("ul");
      this.validationErrors.forEach((error) => {
        errorList.createEl("li", { text: error });
      });
    } else {
      const successSection = containerEl.createDiv();
      successSection.style.marginTop = "20px";
      successSection.style.padding = "10px";
      successSection.style.backgroundColor = "var(--background-modifier-success)";
      successSection.style.borderRadius = "4px";
      successSection.createEl("h4", {
        text: "\u2705 Configuration Valid",
        attr: { style: "color: var(--text-success); margin-top: 0;" }
      });
    }
  }
  /**
   * Create usage instructions
   */
  createUsageInstructions() {
    const { containerEl } = this;
    containerEl.createEl("h3", { text: "Usage Instructions" });
    const instructions = containerEl.createDiv();
    instructions.innerHTML = `
            <p><strong>How to use:</strong></p>
            <ol>
                <li>Set your Gemini or Groq API key above</li>
                <li>Configure your preferred output directory</li>
                <li>Click the video icon in the ribbon or use the command palette</li>
                <li>Paste a YouTube URL and click Process</li>
                <li>The plugin will analyze the video and create a structured note</li>
            </ol>
            
            <p><strong>API Key Information:</strong></p>
            <ul>
                <li><strong>Gemini API:</strong> Get your key from <a href="https://aistudio.google.com/app/apikey">Google AI Studio</a></li>
                <li><strong>Groq API:</strong> Get your key from <a href="https://console.groq.com/keys">Groq Console</a></li>
                <li>At least one API key is required for the plugin to function</li>
            </ul>
            
            <p><strong>Note:</strong> This plugin requires an active internet connection and a valid API key.</p>
            <p><strong>Limitations:</strong> Due to CORS restrictions, full transcript extraction may be limited. The plugin works with available metadata and descriptions.</p>
        `;
  }
  /**
   * Update a setting value
   */
  async updateSetting(key, value) {
    try {
      this.settings[key] = value;
      await this.validateAndSaveSettings();
    } catch (error) {
      ErrorHandler.handle(error, `Settings update for ${key}`);
    }
  }
  /**
   * Validate and save settings
   */
  async validateAndSaveSettings() {
    const validation = ValidationUtils.validateSettings(this.settings);
    this.validationErrors = validation.errors;
    if (validation.isValid) {
      await this.options.onSettingsChange(this.settings);
    }
    this.display();
  }
  /**
   * Get current settings
   */
  getSettings() {
    return { ...this.settings };
  }
  /**
   * Update settings from external source
   */
  updateSettings(newSettings) {
    this.settings = { ...newSettings };
    this.display();
  }
};

// src/services/ai/ai-service.ts
init_api();
var AIService = class {
  constructor(providers) {
    this.providers = [];
    if (!providers || providers.length === 0) {
      throw new Error(MESSAGES.ERRORS.MISSING_API_KEYS);
    }
    this.providers = providers;
  }
  /**
   * Return available model options for a provider name (from constants mapping)
   */
  getProviderModels(providerName) {
    const raw = PROVIDER_MODEL_OPTIONS[providerName] || [];
    return raw.map((r) => typeof r === "string" ? r : r && r.name ? r.name : String(r));
  }
  /**
   * Best-effort fetch of latest models for all providers by scraping known provider pages.
   * Returns a mapping providerName -> list of discovered models. Falls back to static mapping.
   */
  async fetchLatestModels() {
    const result = {};
    const providers = this.getProviderNames();
    for (const p of providers) {
      try {
        const models = await this.fetchLatestModelsForProvider(p);
        result[p] = models.length > 0 ? models : PROVIDER_MODEL_OPTIONS[p] ? PROVIDER_MODEL_OPTIONS[p].map((m) => typeof m === "string" ? m : m.name) : [];
      } catch (error) {
        result[p] = PROVIDER_MODEL_OPTIONS[p] ? PROVIDER_MODEL_OPTIONS[p].map((m) => typeof m === "string" ? m : m.name) : [];
      }
    }
    return result;
  }
  /**
   * Fetch latest models for a single provider (best-effort scraping).
   */
  async fetchLatestModelsForProvider(providerName) {
    const url = PROVIDER_MODEL_LIST_URLS[providerName];
    const regex = PROVIDER_MODEL_REGEX[providerName];
    if (!url || !regex) {
      return PROVIDER_MODEL_OPTIONS[providerName] ? PROVIDER_MODEL_OPTIONS[providerName].map((m) => typeof m === "string" ? m : m.name) : [];
    }
    try {
      const resp = await fetch(url, { method: "GET" });
      if (!resp.ok) {
        return PROVIDER_MODEL_OPTIONS[providerName] ? PROVIDER_MODEL_OPTIONS[providerName].map((m) => typeof m === "string" ? m : m.name) : [];
      }
      const text = await resp.text();
      const matches = text.match(regex) || [];
      const normalized = Array.from(new Set(matches.map((m) => m.toLowerCase())));
      return normalized;
    } catch (error) {
      return PROVIDER_MODEL_OPTIONS[providerName] ? PROVIDER_MODEL_OPTIONS[providerName].map((m) => typeof m === "string" ? m : m.name) : [];
    }
  }
  /**
   * Process prompt with fallback support
   */
  async process(prompt) {
    if (!prompt || typeof prompt !== "string") {
      throw new Error("Valid prompt is required");
    }
    let lastError = null;
    for (const provider of this.providers) {
      try {
        console.log(`Attempting to process with ${provider.name}...`);
        const content = await provider.process(prompt);
        if (content && content.trim().length > 0) {
          return {
            content,
            provider: provider.name,
            model: provider.model
          };
        } else {
          throw new Error("Empty response from AI provider");
        }
      } catch (error) {
        lastError = error;
        console.warn(`${provider.name} failed:`, error);
        if (provider === this.providers[this.providers.length - 1]) {
          break;
        }
      }
    }
    const errorMessage = lastError ? MESSAGES.ERRORS.AI_PROCESSING(lastError.message) : "All AI providers failed to process the request";
    throw new Error(errorMessage);
  }
  /**
   * Process prompt using a specific provider name. Optionally override the model if supported.
   */
  async processWith(providerName, prompt, overrideModel) {
    const provider = this.providers.find((p) => p.name === providerName);
    if (!provider) {
      throw new Error(`AI provider not found: ${providerName}`);
    }
    try {
      if (overrideModel && typeof provider.setModel === "function") {
        provider.setModel(overrideModel);
      }
      const content = await provider.process(prompt);
      if (content && content.trim().length > 0) {
        return { content, provider: provider.name, model: provider.model };
      }
      throw new Error("Empty response from AI provider");
    } catch (error) {
      throw new Error(MESSAGES.ERRORS.AI_PROCESSING(error.message));
    }
  }
  /**
   * Check if any providers are available
   */
  hasAvailableProviders() {
    return this.providers.length > 0;
  }
  /**
   * Get list of available provider names
   */
  getProviderNames() {
    return this.providers.map((p) => p.name);
  }
  /**
   * Add a new provider
   */
  addProvider(provider) {
    this.providers.push(provider);
  }
  /**
   * Remove a provider by name
   */
  removeProvider(providerName) {
    const index = this.providers.findIndex((p) => p.name === providerName);
    if (index !== -1) {
      this.providers.splice(index, 1);
      return true;
    }
    return false;
  }
};

// src/services/ai/gemini.ts
init_api();

// src/services/ai/base.ts
var BaseAIProvider = class {
  constructor(apiKey, initialModel) {
    this.apiKey = apiKey;
    if (!apiKey) {
      throw new Error("API key is required for AI provider");
    }
    this._model = initialModel || "";
  }
  get model() {
    return this._model;
  }
  setModel(model) {
    this._model = model;
  }
  /**
   * Validate API response structure
   */
  validateResponse(response, requiredPath) {
    let current = response;
    for (const key of requiredPath) {
      if (!current || typeof current !== "object" || !(key in current)) {
        return false;
      }
      current = current[key];
    }
    return current !== null && current !== void 0;
  }
  /**
   * Handle API errors consistently
   */
  async handleAPIError(response) {
    return ErrorHandler.handleAPIError(response, this.name);
  }
};

// src/services/ai/gemini.ts
var GeminiProvider = class extends BaseAIProvider {
  constructor(apiKey, model) {
    super(apiKey, model || AI_MODELS.GEMINI);
    this.name = "Google Gemini";
  }
  async process(prompt) {
    const response = await fetch(`${API_ENDPOINTS.GEMINI}?key=${this.apiKey}`, {
      method: "POST",
      headers: this.createHeaders(),
      body: JSON.stringify(this.createRequestBody(prompt))
    });
    if (response.status === 401) {
      throw new Error(MESSAGES.ERRORS.GEMINI_INVALID_KEY);
    }
    if (!response.ok) {
      await this.handleAPIError(response);
    }
    const data = await response.json();
    if (!this.validateResponse(data, ["candidates", "0", "content", "parts", "0", "text"])) {
      throw new Error("Invalid response format from Gemini API");
    }
    return this.extractContent(data);
  }
  createHeaders() {
    return {
      "Content-Type": "application/json"
    };
  }
  createRequestBody(prompt) {
    const normalizedPrompt = prompt.toLowerCase();
    const isVideoAnalysis = normalizedPrompt.includes("youtube video") || normalizedPrompt.includes("youtu.be/") || normalizedPrompt.includes("youtube.com/");
    const baseConfig = {
      contents: [{
        parts: [{ text: prompt }]
      }],
      generationConfig: {
        temperature: 0.7,
        maxOutputTokens: 4e3,
        // Increased for detailed guides
        candidateCount: 1
      }
      // safetySettings: [
      //     {
      //         category: "HARM_CATEGORY_HARASSMENT",
      //         threshold: "BLOCK_MEDIUM_AND_ABOVE"
      //     },
      //     {
      //         category: "HARM_CATEGORY_HATE_SPEECH", 
      //         threshold: "BLOCK_MEDIUM_AND_ABOVE"
      //     }
      // ]
    };
    if (isVideoAnalysis) {
      const providerModels = PROVIDER_MODEL_OPTIONS["Google Gemini"] || [];
      const currentModelName = String(this.model || "").toLowerCase();
      const matched = providerModels.find((m) => {
        const name = typeof m === "string" ? m : m && m.name ? m.name : "";
        return String(name).toLowerCase() === currentModelName;
      });
      const supportsAudioVideo = matched && matched.supportsAudioVideo === true;
      const videoConfig = {
        ...baseConfig,
        systemInstruction: {
          parts: [{
            text: `You are an expert video content analyzer. Provide comprehensive, multimodal analysis using:
\u2022 AUDIO STREAM: Transcribe all spoken content, identify speakers, capture tone/emphasis/emotion
\u2022 VIDEO STREAM: Analyze visual elements, text overlays, diagrams, slides, gestures, scene changes, and visual demonstrations
\u2022 INTEGRATED INSIGHTS: Synthesize audio and visual data to provide complete understanding

For best results:
- Prioritize accuracy in transcription and speaker identification
- Extract and explain key concepts shown visually
- Note timing relationships between audio and visual elements
- Identify visual cues that reinforce or clarify spoken content`
          }]
        }
      };
      const gcsMatch = prompt.match(/(gs:\/\/[\w\-\.\/]+\.(?:mp4|mov|mkv|webm))/i);
      if (gcsMatch && gcsMatch[1]) {
        const gcsUri = gcsMatch[1];
        videoConfig.contents = videoConfig.contents || [];
        videoConfig.contents.push({
          parts: [{ fileData: { fileUri: gcsUri, mimeType: "video/mp4" } }]
        });
      }
      return videoConfig;
    }
    return baseConfig;
  }
  extractContent(response) {
    const content = response.candidates[0].content.parts[0].text;
    return content ? content.trim() : "";
  }
};

// src/services/ai/groq.ts
init_api();
var GroqProvider = class extends BaseAIProvider {
  constructor(apiKey, model) {
    super(apiKey, model || AI_MODELS.GROQ);
    this.name = "Groq";
  }
  async process(prompt) {
    const response = await fetch(API_ENDPOINTS.GROQ, {
      method: "POST",
      headers: this.createHeaders(),
      body: JSON.stringify(this.createRequestBody(prompt))
    });
    if (response.status === 404) {
      throw new Error(MESSAGES.ERRORS.GROQ_MODEL_NOT_FOUND);
    }
    if (!response.ok) {
      await this.handleAPIError(response);
    }
    const data = await response.json();
    if (!this.validateResponse(data, ["choices", "0", "message"])) {
      throw new Error("Invalid response format from Groq API");
    }
    return this.extractContent(data);
  }
  createHeaders() {
    return {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${this.apiKey}`
    };
  }
  createRequestBody(prompt) {
    return {
      model: this.model,
      messages: [
        {
          role: "system",
          content: "You are an expert content analyzer specializing in extracting practical value and creating actionable guides from video content. Focus on clarity, practicality, and immediate implementability. Even with limited information, provide maximum value through structured analysis and practical recommendations."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      max_tokens: API_LIMITS.MAX_TOKENS,
      temperature: API_LIMITS.TEMPERATURE
    };
  }
  extractContent(response) {
    const content = response.choices[0].message.content;
    return content ? content.trim() : "";
  }
};

// src/services/youtube/video-data.ts
init_api();
var YouTubeVideoService = class {
  // 30 minutes
  constructor(cache) {
    this.cache = cache;
    this.metadataTTL = 1e3 * 60 * 30;
    // 30 minutes
    this.descriptionTTL = 1e3 * 60 * 30;
  }
  /**
   * Extract video ID from YouTube URL
   */
  extractVideoId(url) {
    return ValidationUtils.extractVideoId(url);
  }
  /**
   * Get video metadata and description
   */
  async getVideoData(videoId) {
    var _a, _b;
    if (!videoId) {
      throw new Error("Video ID is required");
    }
    const cacheKey = this.getCacheKey("video-data", videoId);
    const cached = (_a = this.cache) == null ? void 0 : _a.get(cacheKey);
    if (cached) {
      return cached;
    }
    try {
      const [metadata, description] = await Promise.all([
        this.getVideoMetadata(videoId),
        this.getVideoDescription(videoId)
      ]);
      const result = {
        title: metadata.title || "Unknown Title",
        description: description || "No description available"
      };
      (_b = this.cache) == null ? void 0 : _b.set(cacheKey, result, this.metadataTTL);
      return result;
    } catch (error) {
      throw ErrorHandler.createUserFriendlyError(
        error,
        "fetch video data"
      );
    }
  }
  /**
   * Get video metadata using YouTube oEmbed API
   */
  async getVideoMetadata(videoId) {
    var _a, _b;
    const cacheKey = this.getCacheKey("metadata", videoId);
    const cached = (_a = this.cache) == null ? void 0 : _a.get(cacheKey);
    if (cached) {
      return cached;
    }
    const oembedUrl = `${API_ENDPOINTS.YOUTUBE_OEMBED}?url=https://www.youtube.com/watch?v=${videoId}&format=json`;
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 1e4);
      const response = await fetch(oembedUrl, {
        headers: {
          "User-Agent": "Obsidian YouTube Processor Plugin"
        },
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        if (response.status === 400) {
          throw new Error(`Invalid YouTube video ID: ${videoId}. Please check the URL and try again.`);
        } else if (response.status === 404) {
          throw new Error(`YouTube video not found: ${videoId}. The video may be private, deleted, or the ID is incorrect.`);
        } else if (response.status === 403) {
          throw new Error(`Access denied to YouTube video: ${videoId}. The video may be private or restricted.`);
        } else {
          throw new Error(MESSAGES.ERRORS.FETCH_VIDEO_DATA(response.status));
        }
      }
      const data = await response.json();
      const metadata = {
        title: data.title || "Unknown Title"
      };
      (_b = this.cache) == null ? void 0 : _b.set(cacheKey, metadata, this.metadataTTL);
      return metadata;
    } catch (error) {
      if (error instanceof DOMException && error.name === "AbortError") {
        throw new Error("Request timed out. Please check your internet connection and try again.");
      } else if (error instanceof TypeError) {
        throw new Error(MESSAGES.ERRORS.NETWORK_ERROR);
      } else if (error instanceof Error && error.message.includes("JSON")) {
        throw new Error("Failed to parse YouTube response. The service may be temporarily unavailable.");
      }
      throw error;
    }
  }
  /**
   * Get video description by scraping the YouTube page
   */
  async getVideoDescription(videoId) {
    var _a, _b, _c;
    const cacheKey = this.getCacheKey("description", videoId);
    const cached = (_a = this.cache) == null ? void 0 : _a.get(cacheKey);
    if (cached) {
      return cached;
    }
    try {
      const html = await this.fetchVideoPageHTML(videoId);
      const description = this.extractDescriptionFromHTML(html);
      (_b = this.cache) == null ? void 0 : _b.set(cacheKey, description, this.descriptionTTL);
      return description;
    } catch (error) {
      console.warn("Failed to scrape video page:", error);
      const fallback = MESSAGES.WARNINGS.EXTRACTION_FAILED;
      (_c = this.cache) == null ? void 0 : _c.set(cacheKey, fallback, this.descriptionTTL);
      return fallback;
    }
  }
  /**
   * Fetch YouTube page HTML using CORS proxy
   */
  async fetchVideoPageHTML(videoId) {
    const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
    const proxyUrl = `${API_ENDPOINTS.CORS_PROXY}?url=${encodeURIComponent(videoUrl)}`;
    const response = await fetch(proxyUrl);
    if (!response.ok) {
      throw new Error(MESSAGES.WARNINGS.CORS_RESTRICTIONS);
    }
    return response.text();
  }
  /**
   * Extract description from YouTube page HTML
   */
  extractDescriptionFromHTML(html) {
    const patterns = [
      /"shortDescription":"([^"]*?)"/,
      /"description":{"simpleText":"([^"]*?)"}/,
      /<meta name="description" content="([^"]*?)">/,
      /<meta property="og:description" content="([^"]*?)">/
    ];
    for (const pattern of patterns) {
      const match = html.match(pattern);
      if (match && match[1]) {
        const cleanedText = ValidationUtils.cleanText(match[1]);
        return ValidationUtils.truncateText(cleanedText, API_LIMITS.DESCRIPTION_MAX_LENGTH);
      }
    }
    return MESSAGES.WARNINGS.AUTO_EXTRACTION;
  }
  /**
   * Validate YouTube URL and extract video ID
   */
  validateAndExtractVideoId(url) {
    if (!ValidationUtils.isValidYouTubeUrl(url)) {
      throw new Error(MESSAGES.ERRORS.INVALID_URL);
    }
    const videoId = this.extractVideoId(url);
    if (!videoId) {
      throw new Error(MESSAGES.ERRORS.INVALID_URL);
    }
    return videoId;
  }
  getCacheKey(namespace, videoId) {
    return `youtube-video-service:${namespace}:${videoId}`;
  }
};

// src/services/file/obsidian-file.ts
var import_obsidian6 = require("obsidian");
init_api();

// src/components/modals/file-conflict-modal.ts
init_base_modal();
var COPY_WARNING = "A note with this title already exists. Choose how to proceed.";
var FileConflictModal = class extends BaseModal {
  constructor(app, file) {
    super(app);
    this.file = file;
    this.decision = "cancel";
  }
  onOpen() {
    this.createHeader("Note Already Exists");
    this.createMessage(`${COPY_WARNING}

Existing note: ${this.file.path}`);
    this.createButtons();
  }
  openAndWait() {
    return new Promise((resolve) => {
      this.resolve = resolve;
      this.forceVisible();
      this.open();
    });
  }
  onClose() {
    if (this.resolve) {
      this.resolve(this.decision);
    }
    super.onClose();
  }
  createButtons() {
    const container = this.createButtonContainer();
    this.createButton(container, "Cancel", false, () => {
      this.closeWithDecision("cancel");
    });
    this.createButton(container, "Save as Numbered Copy", false, () => {
      this.closeWithDecision("new-name");
    });
    this.createButton(container, "Overwrite Existing", true, () => {
      this.closeWithDecision("overwrite");
    });
  }
  closeWithDecision(decision) {
    this.decision = decision;
    this.close();
  }
};

// src/services/file/obsidian-file.ts
var ObsidianFileService = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Save content to a file in the vault
   */
  async saveToFile(title, content, outputPath) {
    try {
      const filename = this.createSafeFilename(title);
      const normalizedBase = this.normalizePath(outputPath);
      await this.ensureDirectoryExists(normalizedBase);
      const dailyFolder = this.getDailyFolderPath(normalizedBase);
      await this.ensureDirectoryExists(dailyFolder);
      const filePath = `${dailyFolder}/${filename}`;
      const finalPath = await this.handleFileConflicts(filePath, content);
      return finalPath;
    } catch (error) {
      throw new Error(MESSAGES.ERRORS.SAVE_FILE(error.message));
    }
  }
  /**
   * Open a file with user confirmation
   */
  async openFileWithConfirmation(file) {
    await this.waitForFileCreation();
    try {
      const currentFile = this.app.vault.getAbstractFileByPath(file.path);
      if (!(currentFile instanceof import_obsidian6.TFile)) {
        throw new Error(MESSAGES.ERRORS.FILE_NOT_EXISTS);
      }
      const leaf = this.app.workspace.getLeaf(false);
      await leaf.openFile(currentFile);
    } catch (error) {
      throw new Error(MESSAGES.ERRORS.COULD_NOT_OPEN(error.message));
    }
  }
  /**
   * Create a safe filename from title
   */
  createSafeFilename(title) {
    const sanitized = ValidationUtils.sanitizeFilename(title);
    return `${sanitized}.md`;
  }
  /**
   * Ensure the output directory exists
   */
  async ensureDirectoryExists(outputPath) {
    try {
      await this.app.vault.createFolder(outputPath);
    } catch (error) {
    }
  }
  getDailyFolderPath(basePath) {
    const trimmedBase = basePath.replace(/\/+$/, "");
    const today = new Date().toISOString().split("T")[0];
    return `${trimmedBase}/${today}`;
  }
  /**
   * Handle file naming conflicts by adding timestamp
   */
  async handleFileConflicts(filePath, content) {
    const existingFile = this.app.vault.getAbstractFileByPath(filePath);
    if (existingFile instanceof import_obsidian6.TFile) {
      const decision = await this.promptConflictResolution(existingFile);
      switch (decision) {
        case "overwrite":
          await this.app.vault.modify(existingFile, content);
          return existingFile.path;
        case "new-name":
          return this.createVersionedCopy(existingFile.path, content);
        default:
          throw new Error("Save cancelled by user");
      }
    }
    await this.app.vault.create(filePath, content);
    return filePath;
  }
  /**
   * Wait for file creation to complete
   */
  async waitForFileCreation() {
    return new Promise(
      (resolve) => setTimeout(resolve, TIMEOUTS.FILE_CREATION_WAIT)
    );
  }
  /**
   * Get file by path with validation
   */
  getFileByPath(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    return file instanceof import_obsidian6.TFile ? file : null;
  }
  /**
   * Check if file exists at path
   */
  fileExists(filePath) {
    return this.getFileByPath(filePath) !== null;
  }
  /**
   * Create a file with unique naming
   */
  async createUniqueFile(basePath, content) {
    let counter = 1;
    let filePath = basePath;
    while (this.fileExists(filePath)) {
      const pathParts = basePath.split("/");
      const filename = pathParts.pop();
      const nameWithoutExt = filename.replace(".md", "");
      const newFilename = `${nameWithoutExt} (${counter}).md`;
      filePath = [...pathParts, newFilename].join("/");
      counter++;
    }
    await this.app.vault.create(filePath, content);
    return filePath;
  }
  async promptConflictResolution(file) {
    const modal = new FileConflictModal(this.app, file);
    const decision = await modal.openAndWait();
    return decision;
  }
  async createVersionedCopy(originalPath, content) {
    const pathParts = originalPath.split("/");
    const filename = pathParts.pop();
    const nameWithoutExt = filename.replace(".md", "");
    let counter = 1;
    let candidatePath;
    do {
      candidatePath = [...pathParts, `${nameWithoutExt} (${counter}).md`].join("/");
      counter++;
    } while (this.fileExists(candidatePath));
    await this.app.vault.create(candidatePath, content);
    return candidatePath;
  }
  normalizePath(path) {
    if (!path) {
      return "";
    }
    let normalized = path.trim();
    if (normalized.startsWith("./")) {
      normalized = normalized.slice(2);
    }
    while (normalized.startsWith("/")) {
      normalized = normalized.slice(1);
    }
    normalized = normalized.replace(/\/+/g, "/");
    return normalized;
  }
};

// src/services/prompt-service.ts
var _AIPromptService = class {
  /**
   * Create analysis prompt for YouTube video content with format selection (optimized)
   */
  createAnalysisPrompt(videoData, videoUrl, format = "detailed-guide") {
    const baseContent = _AIPromptService.BASE_TEMPLATE.replace("{{TITLE}}", videoData.title).replace("{{URL}}", videoUrl).replace("{{DESCRIPTION}}", videoData.description);
    if (format === "executive-summary") {
      return this.createExecutiveSummaryPrompt(baseContent, videoUrl);
    }
    if (format === "brief") {
      return this.createBriefPrompt(baseContent, videoUrl);
    }
    return this.createDetailedGuidePrompt(baseContent, videoUrl);
  }
  /**
   * Create a brief prompt: short description plus resources list
   */
  createBriefPrompt(baseContent, videoUrl) {
    const videoId = ValidationUtils.extractVideoId(videoUrl);
    const embedUrl = videoId ? `https://www.youtube-nocookie.com/embed/${videoId}` : videoUrl;
    return `${baseContent}

        OUTPUT FORMAT - BRIEF DESCRIPTION + RESOURCES:

        Use this EXACT template:

        ---
        title: {Video Title}
        source: ${videoUrl}
        created: "${new Date().toISOString().split("T")[0]}"
        modified: "${new Date().toISOString().split("T")[0]}"
        description: "One short paragraph (3-4 sentences) summarizing the video"
        type: youtube-note
        format: brief
        tags:
          - youtube
          - brief
        status: processed
        duration: "[Extract video duration]"
        channel: "[Extract channel name]"
        video_id: "${videoId || "unknown"}"
        processing_date: "${new Date().toISOString()}"
    ai_provider: "__AI_PROVIDER__"
    ai_model: "__AI_MODEL__"
        ---

        <iframe width="640" height="360" src="${embedUrl}" title="{Video Title}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

        ---

        ## Brief Description
        [Provide a concise 3-4 sentence description that captures the core message of the video]

        ## Resources
        - **Original Video:** [Watch on YouTube](${videoUrl})
        - **Channel:** [Creator's Channel](https://youtube.com/channel/[extract-channel-id])
        - **Top resources mentioned or related (links):**
          - [Resource 1]
          - [Resource 2]
          - [Resource 3]

        IMPORTANT: Keep the Brief Description short and focused. Provide 2-3 high-quality resource links that help the reader explore the topic further.`;
  }
  /**
   * Create executive summary prompt (250 words)
   */
  createExecutiveSummaryPrompt(baseContent, videoUrl) {
    const videoId = ValidationUtils.extractVideoId(videoUrl);
    const embedUrl = videoId ? `https://www.youtube-nocookie.com/embed/${videoId}` : videoUrl;
    return `${baseContent}

        OUTPUT FORMAT - EXECUTIVE SUMMARY:
        
        Use this EXACT template:

        ---
        title: {Video Title}
        source: ${videoUrl}
        created: "${new Date().toISOString().split("T")[0]}"
        modified: "${new Date().toISOString().split("T")[0]}"
        description: "Single sentence capturing the core insight"
        type: youtube-note
        format: executive-summary
        tags:
          - youtube
          - executive-summary
          - tag_1
          - tag_2
          - tag_3
        status: processed
        duration: "[Extract video duration]"
        channel: "[Extract channel name]"
        video_id: "${videoId || "unknown"}"
        processing_date: "${new Date().toISOString()}"
        word_count: 250
    ai_provider: "__AI_PROVIDER__"
    ai_model: "__AI_MODEL__"
        ---

        <iframe width="640" height="360" src="${embedUrl}" title="{Video Title}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

        ---

        ## Key Insights
        - [Critical insight 1 with specific detail]
        - [Critical insight 2 with specific detail]
        - [Critical insight 3 with specific detail]

        ## Concise Summary
        [Provide a concise, cohesive summary in exactly two paragraphs, maximum 250 words total. Focus on the core value, main insights, and key actionable takeaways. Make every word count.]

        ## Resources
        - **Original Video:** [Watch on YouTube](${videoUrl})
        - **Channel:** [Creator's Channel](https://youtube.com/channel/[extract-channel-id])
        - **Key Tools/Frameworks:** [List main tools or frameworks mentioned]
        - **Official Documentation:** [Links to official docs for mentioned technologies]
        - **Further Reading:** [1-2 high-quality related articles or resources]

        CRITICAL: Keep the Executive Summary section to exactly 250 words or fewer. Be concise but comprehensive.`;
  }
  /**
   * Create detailed guide prompt
   */
  createDetailedGuidePrompt(baseContent, videoUrl) {
    const videoId = ValidationUtils.extractVideoId(videoUrl);
    const embedUrl = videoId ? `https://www.youtube-nocookie.com/embed/${videoId}` : videoUrl;
    return `${baseContent}

        OUTPUT FORMAT - COMPREHENSIVE TUTORIAL:

        Use this EXACT template:

        ---
        title: {Video Title}
        source: ${videoUrl}
        created: "${new Date().toISOString().split("T")[0]}"
        modified: "${new Date().toISOString().split("T")[0]}"
        description: "Single sentence capturing the core insight"
        type: youtube-note
        format: detailed-tutorial
        tags:
          - youtube
          - tutorial
          - step-by-step
          - tag_1
          - tag_2
          - tag_3
        status: processed
        duration: "[Extract video duration]"
        channel: "[Extract channel name]"
        video_id: "${videoId || "unknown"}"
        processing_date: "${new Date().toISOString()}"
        word_count: "[estimated word count]"
    ai_provider: "__AI_PROVIDER__"
    ai_model: "__AI_MODEL__"
        difficulty: "[beginner/intermediate/advanced]"
        estimated_time: "[time to complete]"
        ---

        <iframe width="640" height="360" src="${embedUrl}" title="{Video Title}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

        ---

        ## Comprehensive Tutorial

        ### Concise Summary

        [Two-part response: a concise summary under 150 words that captures the video's core value and main insights]

        ## Step-by-Step Implementation Guide
        ### Step 1: [Action Title]
        - Detailed instruction 1
        - Detailed instruction 2
        - Key considerations or tips
        
        ### Step 2: [Action Title]
        - Detailed instruction 1
        - Detailed instruction 2
        - Key considerations or tips

        [Continue with additional steps as needed - provide comprehensive coverage]

        ## Resources
        - **Original Video:** [Watch on YouTube](${videoUrl})
        - **Channel:** [Creator's Channel](https://youtube.com/channel/[extract-channel-id])
        - **Related Documentation:** [If any tools/frameworks mentioned, provide official docs links]
        - **Additional Learning:** [Suggest 2-3 related high-quality resources]
        - **Tools & Software:** [List any tools mentioned with download/setup links]
        - **Community:** [Relevant forums, Discord servers, or communities]

        IMPORTANT: Provide detailed, actionable steps that someone could follow to implement the concepts from the video.`;
  }
  /**
   * Process AI response and inject provider information
   */
  processAIResponse(content, provider, model, format) {
    if (!content) {
      return content;
    }
    const providerValue = provider || "unknown";
    const modelValue = model || "unknown";
    let updatedContent = content.replace(/__AI_PROVIDER__/g, providerValue).replace(/__AI_MODEL__/g, modelValue);
    updatedContent = this.ensureFrontMatterValue(updatedContent, "ai_provider", providerValue);
    updatedContent = this.ensureFrontMatterValue(updatedContent, "ai_model", modelValue);
    return updatedContent;
  }
  ensureFrontMatterValue(content, key, value) {
    const pattern = new RegExp(`(${key}\\s*:\\s*)(["'])?([^"'\\n]*)(["'])?`, "i");
    if (pattern.test(content)) {
      return content.replace(pattern, (_, prefix, openingQuote, _existing, closingQuote) => {
        const quote = openingQuote || closingQuote ? '"' : "";
        return `${prefix}${quote}${value}${quote}`;
      });
    }
    if (content.startsWith("---")) {
      return content.replace(/^---\s*\n/, `---
${key}: "${value}"
`);
    }
    return content;
  }
  /**
   * Create a summary prompt for shorter content
   */
  createSummaryPrompt(videoData, videoUrl) {
    return `Create a concise summary for this YouTube video:

        Title: ${videoData.title}
        URL: ${videoUrl}
        Description: ${videoData.description}

        Please provide:
        1. A 2-paragraph summary (max 250 words)
        2. 3-5 key takeaways
        3. Main actionable insights

        Format as markdown with clear headings.`;
  }
  /**
   * Validate prompt length and content
   */
  validatePrompt(prompt) {
    return Boolean(prompt) && typeof prompt === "string" && prompt.trim().length > 10 && prompt.length < 5e4;
  }
};
var AIPromptService = _AIPromptService;
// Pre-compiled template fragments for hot paths (performance optimization)
AIPromptService.BASE_TEMPLATE = `Analyze this YouTube video using comprehensive multimodal analysis with audio_video_tokens=True:

        VIDEO INFORMATION:
        Title: {{TITLE}}
        URL: {{URL}}
        Description/Context: {{DESCRIPTION}}

        MULTIMODAL ANALYSIS INSTRUCTIONS:
        1. Watch the complete video using both audio and visual analysis capabilities with audio_video_tokens=True
        2. Extract insights from spoken content, music, sound effects, and ambient audio
        3. Analyze visual elements including:
           - Slides, presentations, and text overlays
           - Diagrams, charts, and visual demonstrations
           - Body language, gestures, and facial expressions
           - Screen recordings, code examples, or software demos
           - Any visual aids or props used
        4. Before responding, perform a web search to find relevant insights or highlights about this topic
        5. Use web search results only when they directly enhance the response by adding clarity, depth, or useful context
        6. Focus on practical, action-oriented information that viewers can implement
        7. Maintain accuracy and cite specific examples from the video when relevant
        8. Identify the main value proposition and key learning objectives`;

// src/services/cache/memory-cache.ts
var MemoryCacheService = class {
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
    this.defaultTTL = 3e5;
    // 5 minutes
    this.lastCleanup = 0;
    this.CLEANUP_INTERVAL = 6e4;
  }
  // 1 minute
  /**
   * Get item from cache (optimized with lazy cleanup)
   */
  get(key) {
    var _a;
    if (this.cache.size > 50) {
      this.cleanup();
    }
    const item = this.cache.get(key);
    if (!item)
      return null;
    const ttl = (_a = item.ttl) != null ? _a : this.defaultTTL;
    if (Date.now() - item.timestamp > ttl) {
      this.cache.delete(key);
      return null;
    }
    return item.data;
  }
  /**
   * Set item in cache
   */
  set(key, data, ttl) {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl
    });
  }
  /**
   * Clear all cache items
   */
  clear() {
    this.cache.clear();
  }
  /**
   * Delete specific cache item
   */
  delete(key) {
    return this.cache.delete(key);
  }
  /**
   * Check if key exists in cache
   */
  has(key) {
    var _a;
    const item = this.cache.get(key);
    if (!item) {
      return false;
    }
    const ttl = (_a = item.ttl) != null ? _a : this.defaultTTL;
    if (Date.now() - item.timestamp > ttl) {
      this.cache.delete(key);
      return false;
    }
    return true;
  }
  /**
   * Get cache size
   */
  size() {
    return this.cache.size;
  }
  /**
   * Clean up expired items (optimized with batched operations)
   */
  cleanup() {
    var _a;
    const now = Date.now();
    if (now - this.lastCleanup < this.CLEANUP_INTERVAL)
      return;
    this.lastCleanup = now;
    const expiredKeys = [];
    for (const [key, item] of this.cache.entries()) {
      const ttl = (_a = item.ttl) != null ? _a : this.defaultTTL;
      if (now - item.timestamp > ttl) {
        expiredKeys.push(key);
      }
    }
    expiredKeys.forEach((key) => this.cache.delete(key));
  }
};

// src/services/service-container.ts
var ServiceContainer = class {
  constructor(settings, app) {
    this.settings = settings;
    this.app = app;
  }
  get aiService() {
    if (!this._aiService) {
      const providers = [];
      if (this.settings.geminiApiKey) {
        providers.push(new GeminiProvider(this.settings.geminiApiKey));
      }
      if (this.settings.groqApiKey) {
        providers.push(new GroqProvider(this.settings.groqApiKey));
      }
      this._aiService = new AIService(providers);
    }
    return this._aiService;
  }
  get videoService() {
    if (!this._videoService) {
      this._videoService = new YouTubeVideoService(this.cacheService);
    }
    return this._videoService;
  }
  get fileService() {
    if (!this._fileService) {
      this._fileService = new ObsidianFileService(this.app);
    }
    return this._fileService;
  }
  get cacheService() {
    if (!this._cacheService) {
      this._cacheService = new MemoryCacheService();
    }
    return this._cacheService;
  }
  get promptService() {
    if (!this._promptService) {
      this._promptService = new AIPromptService();
    }
    return this._promptService;
  }
  /**
   * Update settings and refresh services that depend on them
   */
  async updateSettings(newSettings) {
    this.settings = newSettings;
    this._aiService = void 0;
  }
  /**
   * Clear all cached services
   */
  clearServices() {
    this._aiService = void 0;
    this._videoService = void 0;
    this._fileService = void 0;
    this._cacheService = void 0;
    this._promptService = void 0;
  }
};

// src/main.ts
var PLUGIN_PREFIX = "ytp";
var DEFAULT_SETTINGS = {
  geminiApiKey: "",
  groqApiKey: "",
  outputPath: "YouTube/Processed Videos",
  useEnvironmentVariables: false,
  environmentPrefix: "YTC"
};
var YouTubeProcessorPlugin = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
    this.isUnloading = false;
    this.operationCount = 0;
  }
  async onload() {
    this.logInfo("Initializing YouTube Processor Plugin v1.2.0...");
    const conflicts = ConflictPrevention.checkForPotentialConflicts();
    if (conflicts.length > 0) {
      this.logWarning(`Potential conflicts detected but proceeding: ${conflicts.join(", ")}`);
    }
    try {
      await this.loadSettings();
      await this.initializeServices();
      this.registerUIComponents();
      this.logInfo("YouTube Processor Plugin loaded successfully");
    } catch (error) {
      this.logError("Failed to load plugin", error);
      ErrorHandler.handle(error, "Plugin initialization");
      new import_obsidian7.Notice("Failed to load YouTube Processor Plugin. Check console for details.");
    }
  }
  onunload() {
    var _a;
    this.logInfo("Unloading YouTube Processor Plugin...");
    this.isUnloading = true;
    try {
      (_a = this.serviceContainer) == null ? void 0 : _a.clearServices();
      this.cleanupUIElements();
      ConflictPrevention.cleanupAllElements();
      this.logInfo("YouTube Processor Plugin unloaded successfully");
    } catch (error) {
      this.logError("Error during plugin unload", error);
    }
  }
  async initializeServices() {
    this.serviceContainer = new ServiceContainer(this.settings, this.app);
  }
  registerUIComponents() {
    this.ribbonIcon = this.addRibbonIcon("video", "Process YouTube Video", () => {
      void this.safeShowUrlModal();
    });
    this.addCommand({
      id: `${PLUGIN_PREFIX}-process-youtube-video`,
      name: "Process YouTube Video",
      callback: () => {
        void this.safeShowUrlModal();
      }
    });
    this.addSettingTab(new YouTubeSettingsTab(this.app, {
      plugin: this,
      onSettingsChange: this.handleSettingsChange.bind(this)
    }));
  }
  cleanupUIElements() {
    if (this.ribbonIcon) {
      this.ribbonIcon.remove();
      this.ribbonIcon = void 0;
    }
  }
  async safeShowUrlModal() {
    await this.safeOperation(async () => {
      this.openYouTubeUrlModal();
    }, "Show URL Modal");
  }
  async safeOperation(operation, operationName) {
    if (this.isUnloading) {
      this.logWarning(`Attempted ${operationName} during plugin unload - skipping`);
      return null;
    }
    const opId = ++this.operationCount;
    this.logInfo(`Starting operation ${opId}: ${operationName}`);
    try {
      const result = await operation();
      this.logInfo(`Completed operation ${opId}: ${operationName}`);
      return result;
    } catch (error) {
      this.logError(`Failed operation ${opId}: ${operationName}`, error);
      ErrorHandler.handle(error, operationName);
      return null;
    }
  }
  openYouTubeUrlModal() {
    if (this.isUnloading) {
      ConflictPrevention.log("Plugin is unloading, ignoring modal request");
      return;
    }
    ConflictPrevention.safeOperation(async () => {
      var _a;
      const aiService = (_a = this.serviceContainer) == null ? void 0 : _a.aiService;
      const providers = aiService ? aiService.getProviderNames() : [];
      const modelOptionsMap = this.settings.modelOptionsCache || {};
      if (aiService && (!this.settings.modelOptionsCache || Object.keys(this.settings.modelOptionsCache).length === 0)) {
        for (const p of providers) {
          modelOptionsMap[p] = aiService.getProviderModels(p) || [];
        }
      }
      new YouTubeUrlModal(this.app, {
        onProcess: this.processYouTubeVideo.bind(this),
        onOpenFile: this.openFileByPath.bind(this),
        providers,
        modelOptions: modelOptionsMap,
        fetchModels: async () => {
          try {
            const map = await this.serviceContainer.aiService.fetchLatestModels();
            this.settings.modelOptionsCache = map;
            await this.saveSettings();
            return map;
          } catch (error) {
            return modelOptionsMap;
          }
        }
      }).open();
    }, "YouTube URL Modal").catch((error) => {
      ErrorHandler.handle(error, "Opening YouTube URL modal");
    });
  }
  async processYouTubeVideo(url, format = "detailed-guide", providerName, model) {
    if (this.isUnloading) {
      ConflictPrevention.log("Plugin is unloading, cancelling video processing");
      throw new Error("Plugin is shutting down");
    }
    const result = await ConflictPrevention.safeOperation(async () => {
      new import_obsidian7.Notice(MESSAGES.PROCESSING);
      const validation = ValidationUtils.validateSettings(this.settings);
      if (!validation.isValid) {
        throw new Error(`Configuration invalid: ${validation.errors.join(", ")}`);
      }
      const youtubeService = this.serviceContainer.videoService;
      const aiService = this.serviceContainer.aiService;
      const fileService = this.serviceContainer.fileService;
      const promptService = this.serviceContainer.promptService;
      const videoId = youtubeService.extractVideoId(url);
      if (!videoId) {
        throw new Error(MESSAGES.ERRORS.VIDEO_ID_EXTRACTION);
      }
      const videoData = await youtubeService.getVideoData(videoId);
      const prompt = promptService.createAnalysisPrompt(videoData, url, format);
      let aiResponse;
      if (providerName) {
        aiResponse = await aiService.processWith(providerName, prompt, model);
      } else {
        aiResponse = await aiService.process(prompt);
      }
      const formattedContent = promptService.processAIResponse(
        aiResponse.content,
        aiResponse.provider,
        aiResponse.model,
        format,
        videoData,
        url
      );
      const filePath = await fileService.saveToFile(
        videoData.title,
        formattedContent,
        this.settings.outputPath
      );
      new import_obsidian7.Notice(MESSAGES.SUCCESS(videoData.title));
      return filePath;
    }, "YouTube Video Processing");
    if (!result) {
      throw new Error("Failed to process YouTube video");
    }
    return result;
  }
  async openFileByPath(filePath) {
    try {
      await new Promise((resolve) => setTimeout(resolve, 300));
      const cleanPath = filePath.startsWith("/") ? filePath.substring(1) : filePath;
      const file = this.app.vault.getAbstractFileByPath(cleanPath);
      if (!file || !(file instanceof import_obsidian7.TFile)) {
        throw new Error(`File not found at path: ${cleanPath}`);
      }
      await this.openFileInNewTab(file);
    } catch (error) {
      ErrorHandler.handle(error, "Opening file by path");
      throw error;
    }
  }
  async openFileInNewTab(file) {
    try {
      const leaf = this.app.workspace.getLeaf("tab");
      await leaf.openFile(file);
      this.app.workspace.setActiveLeaf(leaf);
      new import_obsidian7.Notice(`\u{1F4C2} Opened: ${file.name}`);
    } catch (error) {
      try {
        const currentLeaf = this.app.workspace.getLeaf(false);
        await currentLeaf.openFile(file);
        new import_obsidian7.Notice(`\u{1F4C2} Opened: ${file.name}`);
      } catch (fallbackError) {
        ErrorHandler.handle(fallbackError, "Opening file in current tab");
        new import_obsidian7.Notice(`Note saved as "${file.name}" but could not auto-open. Please open manually.`);
      }
    }
  }
  showPersistentSaveConfirmation(file) {
    try {
      const modal = new SaveConfirmationModal(this.app, file, (shouldOpen) => {
        if (shouldOpen) {
          void this.openFileInNewTab(file);
        }
      });
      modal.open();
    } catch (error) {
      ErrorHandler.handle(error, "Showing save confirmation");
      new import_obsidian7.Notice(`File saved: ${file.name}. Click to open.`, 0).noticeEl.onclick = () => {
        void this.openFileInNewTab(file);
      };
    }
  }
  async handleSettingsChange(newSettings) {
    var _a;
    try {
      this.settings = { ...newSettings };
      await this.saveSettings();
      await ((_a = this.serviceContainer) == null ? void 0 : _a.updateSettings(this.settings));
    } catch (error) {
      ErrorHandler.handle(error, "Settings update");
      throw error;
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  getServiceContainer() {
    return this.serviceContainer;
  }
  logInfo(message) {
    ConflictPrevention.log(`[INFO] ${message}`);
  }
  logWarning(message) {
    ConflictPrevention.log(`[WARN] ${message}`, "warn");
  }
  logError(message, error) {
    ConflictPrevention.log(`[ERROR] ${message}: ${error.message}`, "error");
  }
};
